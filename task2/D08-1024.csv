col1,col2
Minimum-error-rate training (MERT) is a bottleneck for current development in statistical machine translation because it is limited in the number of weights it can reliably optimize.,{}
"Building on the work of Watanabe et al., we explore the use of the MIRA algorithm of Crammer et al. as an alternative to MERT.",{}
"We first show that by parallel processing and exploiting more of the parse forest, we can obtain results using MIRA that match or surpass MERT in terms of both translation quality and computational cost.",{}
"We then test the method on two classes of features that address deficiencies in the Hiero hierarchical phrasebased model: first, we simultaneously train a large number of Marton and Resnik’s soft syntactic constraints, and, second, we introduce a novel structural distortion model.",{}
In both cases we obtain significant improvements in translation performance.,{}
"Optimizing them in combination, for a total of 56 feature weights, improve performance by 2.6 a subset of the NIST 2006 Arabic-English evaluation data.",{}
"Since its introduction by Och (2003), minimum error rate training (MERT) has been widely adopted for training statistical machine translation (MT) systems.","{'title': '1 Introduction', 'number': '1'}"
"However, MERT is limited in the number of feature weights that it can optimize reliably, with folk estimates of the limit ranging from 15 to 30 features.","{'title': '1 Introduction', 'number': '1'}"
"One recent example of this limitation is a series of experiments by Marton and Resnik (2008), in which they added syntactic features to Hiero (Chiang, 2005; Chiang, 2007), which ordinarily uses no linguistically motivated syntactic information.","{'title': '1 Introduction', 'number': '1'}"
Each of their new features rewards or punishes a derivation depending on how similar or dissimilar it is to a syntactic parse of the input sentence.,"{'title': '1 Introduction', 'number': '1'}"
"They found that in order to obtain the greatest improvement, these features had to be specialized for particular syntactic categories and weighted independently.","{'title': '1 Introduction', 'number': '1'}"
"Not being able to optimize them all at once using MERT, they resorted to running MERT many times in order to test different combinations of features.","{'title': '1 Introduction', 'number': '1'}"
But it would have been preferable to use a training method that can optimize the features all at once.,"{'title': '1 Introduction', 'number': '1'}"
"There has been much work on improving MERT’s performance (Duh and Kirchoff, 2008; Smith and Eisner, 2006; Cer et al., 2008), or on replacing MERT wholesale (Turian et al., 2007; Blunsom et al., 2008).","{'title': '1 Introduction', 'number': '1'}"
"This paper continues a line of research on online discriminative training (Tillmann and Zhang, 2006; Liang et al., 2006; Arun and Koehn, 2007), extending that of Watanabe et al. (2007), who use the Margin Infused Relaxed Algorithm (MIRA) due to Crammer et al.","{'title': '1 Introduction', 'number': '1'}"
(2003; 2006).,"{'title': '1 Introduction', 'number': '1'}"
"Our guiding principle is practicality: like Watanabe et al., we train on a small tuning set comparable in size to that used by MERT, but by parallel processing and exploiting more of the parse forest, we obtain results using MIRA that match or surpass MERT in terms of both translation quality and computational cost on a large-scale translation task.","{'title': '1 Introduction', 'number': '1'}"
"Taking this further, we test MIRA on two classes of features that make use of syntactic information and hierarchical structure.","{'title': '1 Introduction', 'number': '1'}"
"First, we generalize Marton and Resnik’s (2008) soft syntactic constraints by training all of them simultaneously; and, second, we introduce a novel structural distortion model.","{'title': '1 Introduction', 'number': '1'}"
"We obtain significant improvements in both cases, and further large improvements when the two feature sets are combined.","{'title': '1 Introduction', 'number': '1'}"
The paper proceeds as follows.,"{'title': '1 Introduction', 'number': '1'}"
We describe our training algorithm in section 2; our generalization of Marton and Resnik’s soft syntactic constraints in section 3; our novel structural distortion features in section 4; and experimental results in section 5.,"{'title': '1 Introduction', 'number': '1'}"
"The translation model is a standard linear model (Och and Ney, 2002), which we train using MIRA (Crammer and Singer, 2003; Crammer et al., 2006), following Watanabe et al. (2007).","{'title': '2 Learning algorithm', 'number': '2'}"
We describe the basic algorithm first and then progressively refine it.,"{'title': '2 Learning algorithm', 'number': '2'}"
"Let e, by abuse of notation, stand for both output strings and their derivations.","{'title': '2 Learning algorithm', 'number': '2'}"
We represent the feature vector for derivation e as h(e).,"{'title': '2 Learning algorithm', 'number': '2'}"
"Initialize the feature weights w. Then, repeatedly: passes through the training data are made, we only average the weight vectors from the last pass.)","{'title': '2 Learning algorithm', 'number': '2'}"
"The technique of averaging was introduced in the context of perceptrons as an approximation to taking a vote among all the models traversed during training, and has been shown to work well in practice (Freund and Schapire, 1999; Collins, 2002).","{'title': '2 Learning algorithm', 'number': '2'}"
We follow McDonald et al. (2005) in applying this technique to MIRA.,"{'title': '2 Learning algorithm', 'number': '2'}"
"Note that the objective (1) is not the same as that used by Watanabe et al. ; rather, it is the same as that used by Crammer and Singer (2003) and related to that of Taskar et al.","{'title': '2 Learning algorithm', 'number': '2'}"
(2005).,"{'title': '2 Learning algorithm', 'number': '2'}"
"We solve this optimization problem using a variant of sequential minimal optimization (Platt, 1998): for each i, initialize αij = C for a single value of j such that eij = e∗i , and initialize αij = 0 for all other values of j.","{'title': '2 Learning algorithm', 'number': '2'}"
"Then, repeatedly choose a sentence i and a pair of hypotheses j, j0, and let where where we set C = 0.01.","{'title': '2 Learning algorithm', 'number': '2'}"
"The first term means that we want w0 to be close to w, and second term (the generalized hinge loss) means that we want w0 to score e∗i higher than each eij by a margin at least as wide as the loss `ij.","{'title': '2 Learning algorithm', 'number': '2'}"
"When training is finished, the weight vectors from all iterations are averaged together.","{'title': '2 Learning algorithm', 'number': '2'}"
"(If multiple where the function clip[x,y](z) gives the closest number to z in the interval [x, y].","{'title': '2 Learning algorithm', 'number': '2'}"
"Assuming BLEU as the evaluation criterion, the loss `ij of ei j relative to e∗i should be related somehow to the difference between their BLEU scores.","{'title': '2 Learning algorithm', 'number': '2'}"
"However, BLEU was not designed to be used on individual sentences; in general, the highest-BLEU translation of a sentence depends on what the other sentences in the test set are.","{'title': '2 Learning algorithm', 'number': '2'}"
"Sentence-level approximations to BLEU exist (Lin and Och, 2004; Liang et al., 2006), but we found it most effective to perform BLEU computations in the context of a set O of previously-translated sentences, following Watanabe et al. (2007).","{'title': '2 Learning algorithm', 'number': '2'}"
"However, we don’t try to accumulate translations for the entire dataset, but simply maintain an exponentially-weighted moving average of previous translations.","{'title': '2 Learning algorithm', 'number': '2'}"
"More precisely: For an input sentence f, let e be some hypothesis translation and let {rk} be the set of reference translations for f. Let c(e; {rk}), or simply c(e) for short, be the vector of the following counts: |e|, the effective reference length mink |rk|, and, for 1 ≤ n ≤ 4, the number of n-grams in e, and the number of n-gram matches between e and {rk}.","{'title': '2 Learning algorithm', 'number': '2'}"
"These counts are sufficient to calculate a BLEU score, which we write as BLEU(c(e)).","{'title': '2 Learning algorithm', 'number': '2'}"
The pseudo-document O is an exponentially-weighted moving average of these vectors.,"{'title': '2 Learning algorithm', 'number': '2'}"
"That is, for each training sentence, let eˆ be the 1-best translation; after processing the sentence, we update O, and its input length Of: We can then calculate the BLEU score of hypotheses e in the context of O.","{'title': '2 Learning algorithm', 'number': '2'}"
"But the larger O is, the smaller the impact the current sentence will have on the BLEU score.","{'title': '2 Learning algorithm', 'number': '2'}"
"To correct for this, and to bring the loss function roughly into the same range as typical margins, we scale the BLEU score by the size of the input: which we also simply write as B(e).","{'title': '2 Learning algorithm', 'number': '2'}"
"Finally, the loss function is defined to be: We now describe the selection of e∗.","{'title': '2 Learning algorithm', 'number': '2'}"
We know of three approaches in previous work.,"{'title': '2 Learning algorithm', 'number': '2'}"
"The first is to force the decoder to output the reference sentence exactly, and select the derivation with the highest model score, which Liang et al. (2006) call bold updating.","{'title': '2 Learning algorithm', 'number': '2'}"
"The second uses the decoder to search for the highest-BLEU translation (Tillmann and Zhang, 2006), which Arun and Koehn (2007) call max-BLEU updating.","{'title': '2 Learning algorithm', 'number': '2'}"
"Liang et al. and Arun and Koehn experiment with these methods and both opt for a third method, which Liang et al. call local updating: generate an n-best list of translations and select the highest-BLEU translation from it.","{'title': '2 Learning algorithm', 'number': '2'}"
"The intuition is that due to noise in the training data or reference translations, a high-BLEU translation may actually use peculiar rules which it would be undesirable to encourage the model to use.","{'title': '2 Learning algorithm', 'number': '2'}"
"Hence, in local updating, the search for the highest-BLEU translation is limited to the n translations with the highest model score, where n must be determined experimentally.","{'title': '2 Learning algorithm', 'number': '2'}"
"Here, we introduce a new oracle-translation selection method, formulating the intuition behind local updating as an optimization problem: Instead of choosing the highest-BLEU translation from an n-best list, we choose the translation that maximizes a combination of (approximate) BLEU and the model.","{'title': '2 Learning algorithm', 'number': '2'}"
"We can also interpret (10) in the following way: we want e∗ to be the max-BLEU translation, but we also want to minimize (1).","{'title': '2 Learning algorithm', 'number': '2'}"
"So we balance these two criteria against each other: where (B(e) − h(e) · w) is that part of (1) that depends on e∗, and µ is a parameter that controls how much we are willing to allow some translations to have higher BLEU than e∗ if we can better minimize (1).","{'title': '2 Learning algorithm', 'number': '2'}"
Setting µ = 0 would reduce to max-BLEU updating; setting µ = ∞ would never update w at all.,"{'title': '2 Learning algorithm', 'number': '2'}"
Setting µ = 0.5 reduces to equation (10).,"{'title': '2 Learning algorithm', 'number': '2'}"
Figure 1 shows the 10-best unique translations for a single input sentence according to equation (11) under various settings of µ.,"{'title': '2 Learning algorithm', 'number': '2'}"
The points at far right are the translations that are scored highest according to the model.,"{'title': '2 Learning algorithm', 'number': '2'}"
"The p = 0 points in the upper-left corner are typical of oracle translations that would be selected under the max-BLEU policy: they indeed have a very high BLEU score, but are far removed from the translations preferred by the model; thus they would cause violent updates to w. Local updating would select the topmost point labeled p = 1.","{'title': '2 Learning algorithm', 'number': '2'}"
"Our scheme would select one of the p = 0.5 points, which have BLEU scores almost as high as the max-BLEU translations, yet are not very far from the translations preferred by the model.","{'title': '2 Learning algorithm', 'number': '2'}"
What is the set {eij} of translation hypotheses?,"{'title': '2 Learning algorithm', 'number': '2'}"
"Ideally we would let it be the set of all possible translations, and let the objective function (1) take all of them into account.","{'title': '2 Learning algorithm', 'number': '2'}"
"This is the approach taken by Taskar et al. (2004), but their approach assumes that the loss function can be decomposed into local loss functions.","{'title': '2 Learning algorithm', 'number': '2'}"
"Since our loss function cannot be so decomposed, we select: The last case is what Crammer et al. (2006) call max-loss updating (where “loss” refers to the generalized hinge loss) and Taskar et al.","{'title': '2 Learning algorithm', 'number': '2'}"
(2005) call lossaugmented inference.,"{'title': '2 Learning algorithm', 'number': '2'}"
"The rationale here is that since the objective (1) tries to minimize maxj(l'ij − Ahij · w'), we should include the translations that have the highest (l'ij − Ahij · w) in order to approximate the effect of using the whole forest.","{'title': '2 Learning algorithm', 'number': '2'}"
See Figure 1 again for an illustration of the hypotheses selected for a single sentence.,"{'title': '2 Learning algorithm', 'number': '2'}"
The maxBLEU points in the upper left are not included (and would have no effect even if they were included).,"{'title': '2 Learning algorithm', 'number': '2'}"
"The p = oo points in the lower-right are the negative examples: they are poor translations that are scored too high by the model, and the learning algorithm attempts to shift them to the left.","{'title': '2 Learning algorithm', 'number': '2'}"
"To perform the forest rescoring, we need to use several approximations, since an exact search for BLEU-optimal translations is NP-hard (Leusch et al., 2008).","{'title': '2 Learning algorithm', 'number': '2'}"
"For every derivation e in the forest, we calculate a vector c(e) of counts as in Section 2.2 except using unclipped counts of n-gram matches (Dreyer et al., 2007), that is, the number of matches for an ngram can be greater than the number of occurrences of the n-gram in any reference translation.","{'title': '2 Learning algorithm', 'number': '2'}"
"This can be done efficiently by calculating c for every hyperedge (rule application) in the forest: We keep track of n-grams using the same scheme used to incorporate an n-gram language model into the decoder (Wu, 1996; Chiang, 2007).","{'title': '2 Learning algorithm', 'number': '2'}"
"To find the best derivation in the forest, we traverse it bottom-up as usual, and for every set of alternative subtranslations, we select the one with the highest score.","{'title': '2 Learning algorithm', 'number': '2'}"
"But here a rough approximation lurks, because we need to calculate B on the nodes of the forest, but B does not have the optimal substructure property, i.e., the optimal score of a parent node cannot necessarily be calculated from the optimal scores of its children.","{'title': '2 Learning algorithm', 'number': '2'}"
"Nevertheless, we find that this rescoring method is good enough for generating high-BLEU oracle translations and low-BLEU negative examples.","{'title': '2 Learning algorithm', 'number': '2'}"
"One convenient property of MERT is that it is embarrassingly parallel: we decode the entire tuning set sending different sentences to different processors, and during optimization of feature weights, different random restarts can be sent to different processors.","{'title': '2 Learning algorithm', 'number': '2'}"
"In order to make MIRA comparable in efficiency to MERT, we must parallelize it.","{'title': '2 Learning algorithm', 'number': '2'}"
"But with an online learning algorithm, parallelization requires a little more coordination.","{'title': '2 Learning algorithm', 'number': '2'}"
"We run MIRA on each processor simultaneously, with each maintaining its own weight vector.","{'title': '2 Learning algorithm', 'number': '2'}"
"A master process distributes different sentences from the tuning set to each of the processors; when each processor finishes decoding a sentence, it transmits the resulting hypotheses, with their losses, to all the other processors and receives any hypotheses waiting from other processors.","{'title': '2 Learning algorithm', 'number': '2'}"
"Those hypotheses were generated from different weight vectors, but can still provide useful information.","{'title': '2 Learning algorithm', 'number': '2'}"
The sets of hypotheses thus collected are then processed as one batch.,"{'title': '2 Learning algorithm', 'number': '2'}"
"When the whole training process is finished, we simply average all the weight vectors from all the processors.","{'title': '2 Learning algorithm', 'number': '2'}"
"Having described our training algorithm, which includes several practical improvements to Watanabe et al.’s usage of MIRA, we proceed in the remainder of the paper to demonstrate the utility of the our training algorithm on models with large numbers of structurally sensitive features.","{'title': '2 Learning algorithm', 'number': '2'}"
The first features we explore are based on a line of research introduced by Chiang (2005) and improved on by Marton and Resnik (2008).,"{'title': '3 Soft syntactic constraints', 'number': '3'}"
"A hierarchical phrase-based translation model is based on synchronous context-free grammar, but does not normally use any syntactic information derived from linguistic knowledge or treebank data: it uses translation rules that span any string of words in the input sentence, without regard for parser-defined syntactic constituency boundaries.","{'title': '3 Soft syntactic constraints', 'number': '3'}"
Chiang (2005) experimented with a constituency feature that rewarded rules whose source language side exactly spans a syntactic constituent according to the output of an external source-language parser.,"{'title': '3 Soft syntactic constraints', 'number': '3'}"
"This feature can be viewed as a soft syntactic constraint: it biases the model toward translations that respect syntactic structure, but does not force it to use them.","{'title': '3 Soft syntactic constraints', 'number': '3'}"
"However, this more syntactically aware model, when tested in Chinese-English translation, did not improve translation performance.","{'title': '3 Soft syntactic constraints', 'number': '3'}"
"Recently, Marton and Resnik (2008) revisited the idea of constituency features, and succeeded in showing that finer-grained soft syntactic constraints yield substantial improvements in BLEU score for both Chinese-English and Arabic-English translation.","{'title': '3 Soft syntactic constraints', 'number': '3'}"
"In addition to adding separate features for different syntactic nonterminals, they introduced a new type of constraint that penalizes rules when the source language side crosses the boundaries of a source syntactic constituent, as opposed to simply rewarding rules when they are consistent with the source-language parse tree.","{'title': '3 Soft syntactic constraints', 'number': '3'}"
Marton and Resnik optimized their features’ weights using MERT.,"{'title': '3 Soft syntactic constraints', 'number': '3'}"
"But since MERT does not scale well to large numbers of feature weights, they were forced to test individual features and manually selected feature combinations each in a separate model.","{'title': '3 Soft syntactic constraints', 'number': '3'}"
"Although they showed gains in translation performance for several such models, many larger, potentially better feature combinations remained unexplored.","{'title': '3 Soft syntactic constraints', 'number': '3'}"
"Moreover, the best-performing feature subset was different for the two language pairs, suggesting that this labor-intensive feature selection process would have to be repeated for each new language pair.","{'title': '3 Soft syntactic constraints', 'number': '3'}"
"Here, we use MIRA to optimize Marton and Resnik’s finer-grained single-category features all at once.","{'title': '3 Soft syntactic constraints', 'number': '3'}"
"We define below two sets of features, a coarsegrained class that combines several constituency categories, and a fine-grained class that puts different categories into different features.","{'title': '3 Soft syntactic constraints', 'number': '3'}"
"Both kinds of features were used by Marton and Resnik, but only a few at a time.","{'title': '3 Soft syntactic constraints', 'number': '3'}"
"Crucially, our training algorithm provides the ability to train all the fine-grained features, a total of 34 feature weights, simultaneously.","{'title': '3 Soft syntactic constraints', 'number': '3'}"
"Coarse-grained features As the basis for coarsegrained syntactic features, we selected the following nonterminal labels based on their frequency in the tuning data, whether they frequently cover a span of more than one word, and whether they represent linguistically relevant constituents: NP, PP, S, VP, SBAR, ADJP, ADVP, and QP.","{'title': '3 Soft syntactic constraints', 'number': '3'}"
"We define two new features, one which fires when a rule’s source side span in the input sentence matches any of the above-mentioned labels in the input parse, and another which fires when a rule’s source side span crosses a boundary of one of these labels (e.g., its source side span only partially covers the words in a VP subtree, and it also covers some or all or the words outside the VP subtree).","{'title': '3 Soft syntactic constraints', 'number': '3'}"
"These two features are equivalent to Marton and Resnik’s XP= and XP' feature combinations, respectively.","{'title': '3 Soft syntactic constraints', 'number': '3'}"
"Fine-grained features We selected the following nonterminal labels that appear more than 100 times in the tuning data: NP, PP, S, VP, SBAR, ADJP, WHNP, PRT, ADVP, PRN, and QP.","{'title': '3 Soft syntactic constraints', 'number': '3'}"
"The labels that were excluded were parts of speech, nonconstituent labels like FRAG, or labels that occurred only two or three times.","{'title': '3 Soft syntactic constraints', 'number': '3'}"
"For each of these labels X, we added a separate feature that fires when a rule’s source side span in the input sentence matches X, and a second feature that fires when a span crosses a boundary of X.","{'title': '3 Soft syntactic constraints', 'number': '3'}"
"These features are similar to Marton and Resnik’s X= and X+, except that our set includes features for WHNP, PRT, and PRN.","{'title': '3 Soft syntactic constraints', 'number': '3'}"
"In addition to parser-based syntactic constraints, which were introduced in prior work, we introduce a completely new set of features aimed at improving the modeling of reordering within Hiero.","{'title': '4 Structural distortion features', 'number': '4'}"
"Again, the feature definition gives rise to a larger number of features than one would expect to train successfully using MERT.","{'title': '4 Structural distortion features', 'number': '4'}"
"In a phrase-based model, reordering is performed both within phrase pairs and by the phrasereordering model.","{'title': '4 Structural distortion features', 'number': '4'}"
"Both mechanisms are able to learn that longer-distance reorderings are more costly than shorter-distance reorderings: phrase pairs, because phrases that involve more extreme reorderings will (presumably) have a lower count in the data, and phrase reordering, because models are usually explicitly dependent on distance.","{'title': '4 Structural distortion features', 'number': '4'}"
"By contrast, in a hierarchical model, all reordering is performed by a single mechanism, the rules of the grammar.","{'title': '4 Structural distortion features', 'number': '4'}"
"In some cases, the model will be able to learn a preference for shorter-distance reorderings, as in a phrase-based system, but in the case of a word being reordered across a nonterminal, or two nonterminals being reordered, there is no dependence in the model on the size of the nonterminal or nonterminals involved in reordering.","{'title': '4 Structural distortion features', 'number': '4'}"
"So, for example, if we have rules we might expect that rule (12) is more common in general, but that rule (13) becomes more and more rare as X1 gets larger.","{'title': '4 Structural distortion features', 'number': '4'}"
The default Hiero features have no way to learn this.,"{'title': '4 Structural distortion features', 'number': '4'}"
"To address this defect, we can classify every nonterminal pair occurring on the right-hand side of each grammar rule as “reordered” or “not reordered”, that is, whether it intersects any other word alignment link or nonterminal pair (see Figure 2).","{'title': '4 Structural distortion features', 'number': '4'}"
We then define coarse- and fine-grained versions of the structural distortion model.,"{'title': '4 Structural distortion features', 'number': '4'}"
"Coarse-grained features Let R be a binaryvalued random variable that indicates whether a nonterminal occurrence is reordered, and let S be an integer-valued random variable that indicates how many source words are spanned by the nonterminal occurrence.","{'title': '4 Structural distortion features', 'number': '4'}"
"We can estimate P(R  |S) via relativefrequency estimation from the rules as they are extracted from the parallel text, and incorporate this probability as a new feature of the model.","{'title': '4 Structural distortion features', 'number': '4'}"
"Fine-grained features A difficulty with the coarse-grained reordering features is that the grammar extraction process finds overlapping rules in the training data and might not give a sensible probability estimate; moreover, reordering statistics from the training data might not carry over perfectly into the translation task (in particular, the training data may have some very freely-reordering translations that one might want to avoid replicating in translation).","{'title': '4 Structural distortion features', 'number': '4'}"
"As an alternative, we introduce a fine-grained version of our distortion model that can be trained directly in the translation task as follows: define a separate binary feature for each value of (R, S), where R is as above and S E J*, 1, ... , 9, >_101 and * means any size.","{'title': '4 Structural distortion features', 'number': '4'}"
"For example, if a nonterminal with span 11 has its contents reordered, then the features (true, >_10) and (true, *) would both fire.","{'title': '4 Structural distortion features', 'number': '4'}"
Grouping all sizes of 10 or more into a single feature is designed to avoid overfitting.,"{'title': '4 Structural distortion features', 'number': '4'}"
"Again, using MIRA makes it practical to train with the full fine-grained feature set—coincidentally also a total of 34 features.","{'title': '4 Structural distortion features', 'number': '4'}"
"We now describe our experiments to test MIRA and our features, the soft-syntactic constraints and the structural distortion features, on an Arabic-English translation task.","{'title': '5 Experiment and results', 'number': '5'}"
"It is worth noting that this experimentation is on a larger scale than Watanabe et al.’s (2007), and considerably larger than Marton and Resnik’s (2008).","{'title': '5 Experiment and results', 'number': '5'}"
"The baseline model was Hiero with the following baseline features (Chiang, 2005; Chiang, 2007): The probability features are base-100 logprobabilities.","{'title': '5 Experiment and results', 'number': '5'}"
"The rules were extracted from all the allowable parallel text from the NIST 2008 evaluation (152+175 million words of Arabic+English), aligned by IBM Model 4 using GIZA++ (union of both directions).","{'title': '5 Experiment and results', 'number': '5'}"
Hierarchical rules were extracted from the most in-domain corpora (4.2+5.4 million words) and phrases were extracted from the remainder.,"{'title': '5 Experiment and results', 'number': '5'}"
"We trained the coarse-grained distortion model on 10,000 sentences of the training data.","{'title': '5 Experiment and results', 'number': '5'}"
"Two language models were trained, one on data similar to the English side of the parallel text and one on 2 billion words of English.","{'title': '5 Experiment and results', 'number': '5'}"
"Both were 5gram models with modified Kneser-Ney smoothing, lossily compressed using a perfect-hashing scheme similar to that of Talbot and Brants (2008) but using minimal perfect hashing (Botelho et al., 2005).","{'title': '5 Experiment and results', 'number': '5'}"
We partitioned the documents of the NIST 2004 (newswire) and 2005 Arabic-English evaluation data into a tuning set (1178 sentences) and a development set (1298 sentences).,"{'title': '5 Experiment and results', 'number': '5'}"
"The test data was the NIST 2006 Arabic-English evaluation data (NIST part, newswire and newsgroups, 1529 sentences).","{'title': '5 Experiment and results', 'number': '5'}"
"To obtain syntactic parses for this data, we tokenized it according to the Arabic Treebank standard using AMIRA (Diab et al., 2004), parsed it with the Stanford parser (Klein and Manning, 2003), and then forced the trees back into the MT system’s tokenization.1 We ran both MERT and MIRA on the tuning set using 20 parallel processors.","{'title': '5 Experiment and results', 'number': '5'}"
"We stopped MERT when the score on the tuning set stopped increasing, as is common practice, and for MIRA, we used the development set to decide when to stop training.2 In our runs, MERT took an average of 9 passes through the tuning set and MIRA took an average of 8 passes.","{'title': '5 Experiment and results', 'number': '5'}"
"(For comparison, Watanabe et al. report decoding their tuning data of 663 sentences 80 times.)","{'title': '5 Experiment and results', 'number': '5'}"
Table 1 shows the results of our experiments with the training methods and features described above.,"{'title': '5 Experiment and results', 'number': '5'}"
"All significance testing was performed against the first line (MERT baseline) using paired bootstrap resampling (Koehn, 2004).","{'title': '5 Experiment and results', 'number': '5'}"
"First of all, we find that MIRA is competitive with MERT when both use the baseline feature set.","{'title': '5 Experiment and results', 'number': '5'}"
"Indeed, the MIRA system scores significantly higher on the test set; but if we break the test set down by genre, we see that the MIRA system does slightly worse on newswire and better on newsgroups.","{'title': '5 Experiment and results', 'number': '5'}"
"(This is largely attributable to the fact that the MIRA translations tend to be longer than the MERT translations, and the newsgroup references are also relatively longer than the newswire references.)","{'title': '5 Experiment and results', 'number': '5'}"
"When we add more features to the model, the two training methods diverge more sharply.","{'title': '5 Experiment and results', 'number': '5'}"
"When training with MERT, the coarse-grained pair of syntax features yields a small improvement, but the finegrained syntax features do not yield any further improvement.","{'title': '5 Experiment and results', 'number': '5'}"
"By contrast, when the fine-grained features are trained using MIRA, they yield substantial improvements.","{'title': '5 Experiment and results', 'number': '5'}"
"We observe similar behavior for the structural distortion features: MERT is not able to take advantage of the finer-grained features, but MIRA is.","{'title': '5 Experiment and results', 'number': '5'}"
"Finally, using MIRA to combine both classes of features, 56 in all, produces the largest improvement, 2.6 BLEU points over the MERT baseline on the full test set.","{'title': '5 Experiment and results', 'number': '5'}"
We also tested some of the differences between our training method and Watanabe et al.’s (2007); the results are shown in Table 2.,"{'title': '5 Experiment and results', 'number': '5'}"
"Compared with local updating (line 2), our method of selecting the oracle translation and negative examples does better by 0.5 BLEU points on the development data.","{'title': '5 Experiment and results', 'number': '5'}"
Using lossaugmented inference to add negative examples to local updating (line 3) does not appear to help.,"{'title': '5 Experiment and results', 'number': '5'}"
"Nevertheless, the negative examples are important: for if Setting Dev full 53.6 local updating, no LAI local updating, LAI p = 0.5 oracle, no LAI no sharing of updates 53.1−− we use our method for selecting the oracle translation without the additional negative examples (line 4), the algorithm fails, generating very long translations and unable to find a weight setting to shorten them.","{'title': '5 Experiment and results', 'number': '5'}"
"It appears, then, that the additional negative examples enable the algorithm to reliably learn from the enhanced oracle translations.","{'title': '5 Experiment and results', 'number': '5'}"
"Finally, we compared our parallelization method against a simpler method in which all processors learn independently and their weight vectors are all averaged together (line 5).","{'title': '5 Experiment and results', 'number': '5'}"
We see that sharing information among the processors makes a significant difference.,"{'title': '5 Experiment and results', 'number': '5'}"
"In this paper, we have brought together two existing lines of work: the training method of Watanabe et al. (2007), and the models of Chiang (2005) and Marton and Resnik (2008).","{'title': '6 Conclusions', 'number': '6'}"
"Watanabe et al.’s work showed that large-margin training with MIRA can be made feasible for state-of-the-art MT systems by using a manageable tuning set; we have demonstrated that parallel processing and exploiting more of the parse forest improves MIRA’s performance and that, even using the same set of features, MIRA’s performance compares favorably to MERT in terms of both translation quality and computational cost.","{'title': '6 Conclusions', 'number': '6'}"
Marton and Resnik (2008) showed that it is possible to improve translation in a data-driven framework by incorporating source-side syntactic analysis in the form of soft syntactic constraints.,"{'title': '6 Conclusions', 'number': '6'}"
This work joins a growing body of work demonstrating the utility of syntactic information in statistical MT.,"{'title': '6 Conclusions', 'number': '6'}"
"In the area of source-side syntax, recent research has continued to improve tree-to-string translation models, soften the constraints of the input tree in various ways (Mi et al., 2008; Zhang et al., 2008), and extend phrase-based translation with sourceside soft syntactic constraints (Cherry, 2008).","{'title': '6 Conclusions', 'number': '6'}"
"All this work shows strong promise, but Marton and Resnik’s soft syntactic constraint approach is particularly appealing because it can be used unobtrusively with any hierarchically-structured translation model.","{'title': '6 Conclusions', 'number': '6'}"
"Here, we have shown that using MIRA to weight all the constraints at once removes the crucial drawback of the approach, the problem of feature selection.","{'title': '6 Conclusions', 'number': '6'}"
"Finally, we have introduced novel structural distortion features to fill a notable gap in the hierarchical phrase-based approach.","{'title': '6 Conclusions', 'number': '6'}"
"By capturing how reordering depends on constituent length, these features improve translation quality significantly.","{'title': '6 Conclusions', 'number': '6'}"
"In sum, we have shown that removing the bottleneck of MERT opens the door to many possibilities for better translation.","{'title': '6 Conclusions', 'number': '6'}"
Thanks to Michael Bloodgood for performing initial simulations of parallelized perceptron training.,"{'title': 'Acknowledgments', 'number': '7'}"
"Thanks also to John DeNero, Kevin Knight, Daniel Marcu, and Fei Sha for valuable discussions and suggestions.","{'title': 'Acknowledgments', 'number': '7'}"
This research was supported in part by DARPA contract HR0011-06-C-0022 under subcontract to BBN Technologies and HR0011-06-02-001 under subcontract to IBM.,"{'title': 'Acknowledgments', 'number': '7'}"
