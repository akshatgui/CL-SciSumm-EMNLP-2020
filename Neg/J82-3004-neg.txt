In addition to the cases of left-linear and right linear grammars discussed in Section 3, our algorithm is exact in a variety of interesting cases, including the examples of Church and Patil (1982), which illustrate how typical attachment ambiguities arise as structural ambiguities on regular string sets. $$$$$ We would like to thank Jon Allen, Sarah Ferguson, Lowell Hawkinson, Kris Halvorsen, Bill Long, Mitch Marcus, Rohit Parikh, and Peter Szolovits for their very useful comments on earlier drafts.
In addition to the cases of left-linear and right linear grammars discussed in Section 3, our algorithm is exact in a variety of interesting cases, including the examples of Church and Patil (1982), which illustrate how typical attachment ambiguities arise as structural ambiguities on regular string sets. $$$$$ The power series for grammar (5a) is (5b).
In addition to the cases of left-linear and right linear grammars discussed in Section 3, our algorithm is exact in a variety of interesting cases, including the examples of Church and Patil (1982), which illustrate how typical attachment ambiguities arise as structural ambiguities on regular string sets. $$$$$ We now substitute (41a-c) into (40c).

In contrast, our method will produce an exact FSA for many interesting grammars generating regular languages, such as those arising from systematic attachment ambiguities (Church and Patil, 1982). $$$$$ (42) VP = V NP (1 + PP)ADJS = V (N E Cati(P N)')(E Cati(P (E adji) and simplify the convolution of the two Catalan functions (43) VP = V (N E Cati+i(P N)i)(E adj') so that the parser can also find VPs by just counting coccurrences of terminal symbols.
In contrast, our method will produce an exact FSA for many interesting grammars generating regular languages, such as those arising from systematic attachment ambiguities (Church and Patil, 1982). $$$$$ Recall that Cat, is interpreted as the ith index in a table containing all binary trees dominating i leaves.
In contrast, our method will produce an exact FSA for many interesting grammars generating regular languages, such as those arising from systematic attachment ambiguities (Church and Patil, 1982). $$$$$ We have presented combination rules in three different representation systems: power series, ATNs, and context-free grammars, each of which contributed its own insights.
In contrast, our method will produce an exact FSA for many interesting grammars generating regular languages, such as those arising from systematic attachment ambiguities (Church and Patil, 1982). $$$$$ We would like to thank Jon Allen, Sarah Ferguson, Lowell Hawkinson, Kris Halvorsen, Bill Long, Mitch Marcus, Rohit Parikh, and Peter Szolovits for their very useful comments on earlier drafts.

As the NP length increases, the number of possible binary trees (parses) increases with the Catalan numbers (Church and Patil, 1982). $$$$$ Transforms are often very useful because they provide a different point of view.
As the NP length increases, the number of possible binary trees (parses) increases with the Catalan numbers (Church and Patil, 1982). $$$$$ However, a full parser is not really necessary for this task; a recognizer such as this table lookup pseudo-parser may be perfectly adequate for this task.
As the NP length increases, the number of possible binary trees (parses) increases with the Catalan numbers (Church and Patil, 1982). $$$$$ We would especially like to thank Bill Martin for initiating the project.

Coordination ambiguity is under-explored, despite being one of the three major sources of structural ambiguity (together with prepositional phrase attachment and noun compound bracketing), and belonging to the class of ambiguities for which the number of analyses is the number of binary trees over the corresponding nodes (Church and Patil, 1982), and despite the fact that conjunctions are among the most frequent words. $$$$$ All and only these possibilities are permitted by the grammar.
Coordination ambiguity is under-explored, despite being one of the three major sources of structural ambiguity (together with prepositional phrase attachment and noun compound bracketing), and belonging to the class of ambiguities for which the number of analyses is the number of binary trees over the corresponding nodes (Church and Patil, 1982), and despite the fact that conjunctions are among the most frequent words. $$$$$ This linear systems view &quot;bundles up&quot; all the parse trees into a single concise description capable of telling us everything we might want to know about the parses (including how much it might cost to ask a particular question).
Coordination ambiguity is under-explored, despite being one of the three major sources of structural ambiguity (together with prepositional phrase attachment and noun compound bracketing), and belonging to the class of ambiguities for which the number of analyses is the number of binary trees over the corresponding nodes (Church and Patil, 1982), and despite the fact that conjunctions are among the most frequent words. $$$$$ (All summations range from 0 to 00 unless noted otherwise.)
Coordination ambiguity is under-explored, despite being one of the three major sources of structural ambiguity (together with prepositional phrase attachment and noun compound bracketing), and belonging to the class of ambiguities for which the number of analyses is the number of binary trees over the corresponding nodes (Church and Patil, 1982), and despite the fact that conjunctions are among the most frequent words. $$$$$ The table lookup routine will employ a more traditional parsing algorithm (e.g., Earley's algorithm) when the number of phrases in the input sentence is not stored in the table.

The number of possible binary-branching parses of a sentence is defined by the Catalan number, an exponential combinatoric function (Church and Patil, 1982), so dynamic programming is crucial for efficiency. $$$$$ The table lookup approach works for primitive grammars.
The number of possible binary-branching parses of a sentence is defined by the Catalan number, an exponential combinatoric function (Church and Patil, 1982), so dynamic programming is crucial for efficiency. $$$$$ Copyright 1982 by the Association for Computational Linguistics.
The number of possible binary-branching parses of a sentence is defined by the Catalan number, an exponential combinatoric function (Church and Patil, 1982), so dynamic programming is crucial for efficiency. $$$$$ (All summations range from 0 to 00 unless noted otherwise.)
