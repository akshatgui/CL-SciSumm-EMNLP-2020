 $$$$$ The empirical results in section 5 are based on this parser.
 $$$$$ Kazuhiro Toyoshima and Hideto Kagamida have implemented the runtime parser and the LR table compiler, respectively, in Common Lisp.
 $$$$$ The algorithm is fast, due to the LR table precomputation.
 $$$$$ By looking at the action table, the next action, &quot;shift 4&quot;, is determined as in standard LR parsing.

Similar to the work of Lang (1974) and Tomita (1987) extending LR parsers for arbitrary CFGs, the LR parsers for TAGs can be extended to solve by pseudo-parallelism the conflicts of moves. $$$$$ The parsing table can be obtained automatically from a context-free phrase structure grammar, using an algorithm first developed by DeRemer (1969, 1971).
Similar to the work of Lang (1974) and Tomita (1987) extending LR parsers for arbitrary CFGs, the LR parsers for TAGs can be extended to solve by pseudo-parallelism the conflicts of moves. $$$$$ The exact definition and operation of the LR parser can be found in Aho and Ullman (1977).

We developed a set of augmented context free grammar rules for general English syntactic analysis and the analyzer is implemented using Tomita LR parsing algorithm (Tomita, 1987). $$$$$ This is especially the case for interactive systems such as natural language database access, interfaces to expert systems, and interactive machine translation.
We developed a set of augmented context free grammar rules for general English syntactic analysis and the analyzer is implemented using Tomita LR parsing algorithm (Tomita, 1987). $$$$$ We adopt pseudo-parallelism (breadth-first search), maintaining a list of stacks (the Stack List).

The RASP parser is a generalized LR parser which builds a non-deterministic generalized LALR parse table from the grammar (Tomita, 1987). $$$$$ The Earley/Tomita ratio seems to increase as the size of grammar grows as shown in Figure 5.3.
The RASP parser is a generalized LR parser which builds a non-deterministic generalized LALR parse table from the grammar (Tomita, 1987). $$$$$ Section 7 describes the concept of on-line parsing, taking advantage of left-to-right operation of our parsing algorithm.
The RASP parser is a generalized LR parser which builds a non-deterministic generalized LALR parse table from the grammar (Tomita, 1987). $$$$$ The sample sentences are created from the following schema. noun verb det noun (prep det noun)n-1 An example sentence with this structure is I saw a man in the park on the hill with a telescope.
The RASP parser is a generalized LR parser which builds a non-deterministic generalized LALR parse table from the grammar (Tomita, 1987). $$$$$ All programs are run on DEC-20 and written in MacLisp, but not compiled.

a graph-structured stack (Tomita, 1987) was used to efficiently represent ambiguous index operations in a GIG stack. $$$$$ The algorithm is a generalized LR parsing algorithm, which precomputes an LR shift-reduce parsing table (possibly with multiple entries) from a given augmented context-free grammar.
a graph-structured stack (Tomita, 1987) was used to efficiently represent ambiguous index operations in a GIG stack. $$$$$ Next Word = 'saw' 0 0 4 9-11F-40 (p.31 0 [6n ' I' ] We reduce the stack basically in the same manner as standard LR parsing.
a graph-structured stack (Tomita, 1987) was used to efficiently represent ambiguous index operations in a GIG stack. $$$$$ The parser is used in the multi-lingual machine translation project at CMU.
a graph-structured stack (Tomita, 1987) was used to efficiently represent ambiguous index operations in a GIG stack. $$$$$ The algorithm parses a sentence strictly from left to right on-line, that is, it starts parsing as soon as the user types in the first word of a sentence, without waiting for completion of the sentence.

A context-free backbone is automatically derived from the unification grammar1 and a generalized or non-deterministic LALR(1) table is constructed from this backbone (Tomita, 1987). $$$$$ We use the same grammar and parsing table as in the first example (Figures 2.1 and 2.2).
A context-free backbone is automatically derived from the unification grammar1 and a generalized or non-deterministic LALR(1) table is constructed from this backbone (Tomita, 1987). $$$$$ The algorithm is fast, due to the LR table precomputation.
A context-free backbone is automatically derived from the unification grammar1 and a generalized or non-deterministic LALR(1) table is constructed from this backbone (Tomita, 1987). $$$$$ The exact definition and operation of the LR parser can be found in Aho and Ullman (1977).
A context-free backbone is automatically derived from the unification grammar1 and a generalized or non-deterministic LALR(1) table is constructed from this backbone (Tomita, 1987). $$$$$ Kazuhiro Toyoshima and Hideto Kagamida have implemented the runtime parser and the LR table compiler, respectively, in Common Lisp.

The parsers create parse forests (Tomita, 1987) that incorporate subtree sharing (in which identical sub-analyses are shared between differing superordinate analyses) and node packing (where sub analyses covering the same portion of input whose root categories are in a subsumption relationship are merged into a single node). $$$$$ A practical on-line parser based on the algorithm has been implemented in Common Lisp, and running on Symbolics and HP Al workstations.
The parsers create parse forests (Tomita, 1987) that incorporate subtree sharing (in which identical sub-analyses are shared between differing superordinate analyses) and node packing (where sub analyses covering the same portion of input whose root categories are in a subsumption relationship are merged into a single node). $$$$$ In this section, we present some empirical results of the algorithm's practical performance.

In this parser, the LALR (1) technique (Aho, Sethi Ullman, 1986) is used, in conjunction with a graph-structured stack (Tomita, 1987), adapting for unification-based parsing Kipps's (1989) Tomita-like recogniser that achieves polynomial complexity on input length through caching. $$$$$ Although the experiment is informal, the result show that the Tomita algorithm is about 5 to 10 times faster than Earley's algorithm, due to the pre-compilation of the grammar into the LR table.
In this parser, the LALR (1) technique (Aho, Sethi Ullman, 1986) is used, in conjunction with a graph-structured stack (Tomita, 1987), adapting for unification-based parsing Kipps's (1989) Tomita-like recogniser that achieves polynomial complexity on input length through caching. $$$$$ The algorithm can be viewed as a generalized LR parsing algorithm that can handle arbitrary context-free grammars, including ambiguous grammars.
In this parser, the LALR (1) technique (Aho, Sethi Ullman, 1986) is used, in conjunction with a graph-structured stack (Tomita, 1987), adapting for unification-based parsing Kipps's (1989) Tomita-like recogniser that achieves polynomial complexity on input length through caching. $$$$$ One obvious benefit of on-line parsing is that it reduces the parser's response time significantly.

A forest (Tomita, 1987) compactly encodes an exponential number of parse trees. $$$$$ Notice that those Lisp functions can be precompiled into machine code by the standard Lisp compiler.
A forest (Tomita, 1987) compactly encodes an exponential number of parse trees. $$$$$ I would like to thank Jaime Carbonell, Phil Hayes, James Allen, Herb Simon, Hozumi Tanaka, and Ralph Grishman for their helpful comments on the early version of this paper.
A forest (Tomita, 1987) compactly encodes an exponential number of parse trees. $$$$$ Although the experiment is informal, the result show that the Tomita algorithm is about 5 to 10 times faster than Earley's algorithm, due to the pre-compilation of the grammar into the LR table.
A forest (Tomita, 1987) compactly encodes an exponential number of parse trees. $$$$$ I would like to thank Jaime Carbonell, Phil Hayes, James Allen, Herb Simon, Hozumi Tanaka, and Ralph Grishman for their helpful comments on the early version of this paper.
