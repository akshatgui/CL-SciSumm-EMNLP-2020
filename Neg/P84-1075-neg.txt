Indeed, we have demonstrated the feasibility (Alshawi et al, 1985) of driving a parsing system directly from the information available in LDOCE by constructing dictionary entries for the PATR-H system (Shieber, 1984). $$$$$ The PATR-II formalism was designed as a computer language for encoding linguistic information.
Indeed, we have demonstrated the feasibility (Alshawi et al, 1985) of driving a parsing system directly from the information available in LDOCE by constructing dictionary entries for the PATR-H system (Shieber, 1984). $$$$$ The PATR-II formalism was designed as a computer language for encoding linguistic information.

We borrow the terminology and notation of PATR-II (Shieber, 1984), a minimal constraint-based formalism that extends context-free grammar. $$$$$ The PATR-II formalism was designed as a computer language for encoding linguistic information.
We borrow the terminology and notation of PATR-II (Shieber, 1984), a minimal constraint-based formalism that extends context-free grammar. $$$$$ The author is indebted to Fernando Pereira, Barbara Grosz, and Ray Perrault for their comments on earlier drafts. tics.
We borrow the terminology and notation of PATR-II (Shieber, 1984), a minimal constraint-based formalism that extends context-free grammar. $$$$$ The pursuit of this objective, however, has been a difficult task for at least two reasons: first, this capability is far from being a well-understood phenomenon; second, the tools for teaching computers what we do know about human language are still very primitive.
We borrow the terminology and notation of PATR-II (Shieber, 1984), a minimal constraint-based formalism that extends context-free grammar. $$$$$ PATR-II but with several interesting extensions, including disjunction and negation in the graph structures [Karttunen, 84].

Nearly all existing unification grammars of this kind use either term unification (the kind of unification used in resolution theorem provers, and hence provided as a primitive in PROLOG) or some version of the graph unification proposed by Kay (1985) and Shieber (1984). $$$$$ The PATR-II formalism was designed as a computer language for encoding linguistic information.
Nearly all existing unification grammars of this kind use either term unification (the kind of unification used in resolution theorem provers, and hence provided as a primitive in PROLOG) or some version of the graph unification proposed by Kay (1985) and Shieber (1984). $$$$$ It is important to keep in mind that these methods should not be considered a part of the underlying formalism, but merely &quot;syntactic sugar&quot; to increase the system's utility and allow it to conform to a user's intentions.
Nearly all existing unification grammars of this kind use either term unification (the kind of unification used in resolution theorem provers, and hence provided as a primitive in PROLOG) or some version of the graph unification proposed by Kay (1985) and Shieber (1984). $$$$$ A considerable body of accumulated knowledge about the design of languages for communicating information to computers has been derived from the subfields of programming language design and semantics.
Nearly all existing unification grammars of this kind use either term unification (the kind of unification used in resolution theorem provers, and hence provided as a primitive in PROLOG) or some version of the graph unification proposed by Kay (1985) and Shieber (1984). $$$$$ It has been the goal of the PATR group at SRI to utilize a relevant portion of this knowledge in implementing tools to facilitate communication of linguistic information to computers.

It is not, unfortunately, possible to keep it close to both FUG and PATR (Shieber 1984), but it should be possible for readers familiar with PATR to see roughly what the relation between the two is. $$$$$ Nevertheless, a good case could be made for maintaining at lea.st the decidability of determining whether a string is admitted by a PATR-II grammar.
It is not, unfortunately, possible to keep it close to both FUG and PATR (Shieber 1984), but it should be possible for readers familiar with PATR to see roughly what the relation between the two is. $$$$$ It has been the goal of the PATR group at SRI to utilize a relevant portion of this knowledge in implementing tools to facilitate communication of linguistic information to computers.
It is not, unfortunately, possible to keep it close to both FUG and PATR (Shieber 1984), but it should be possible for readers familiar with PATR to see roughly what the relation between the two is. $$$$$ In fact, templates are currently employed for abstracting notions of subcategorization, verb form, semantic type, and a host of other concepts.
It is not, unfortunately, possible to keep it close to both FUG and PATR (Shieber 1984), but it should be possible for readers familiar with PATR to see roughly what the relation between the two is. $$$$$ These template DAGs can then be combined to build the lexical item out of the user-defined primitives.

 $$$$$ Modularity is achieved through the ability to define primitive templates and lexical rules that are shared among lexical items, as well as by the declarative nature of the grammar formalism itself, removing problems of interaction of rules.
 $$$$$ A considerable body of accumulated knowledge about the design of languages for communicating information to computers has been derived from the subfields of programming language design and semantics.
 $$$$$ Such a language, of which PATR-II is an example, would reflect a felicitous convergence of ideas from linguistics, artificial intelligence, and computer science.
 $$$$$ It has been the goal of the PATR group at SRI to utilize a relevant portion of this knowledge in implementing tools to facilitate communication of linguistic information to computers.

Since formalisms (i) are used in the family of the PATR parsing systems (Shieber, 1984), hereafter they will be called PATR-like formalisms. $$$$$ The PATR-TI formalism is our current computer language for encoding linguistic information.
Since formalisms (i) are used in the family of the PATR parsing systems (Shieber, 1984), hereafter they will be called PATR-like formalisms. $$$$$ Computer languages are a direct result of this need for effective communication with computers.
Since formalisms (i) are used in the family of the PATR parsing systems (Shieber, 1984), hereafter they will be called PATR-like formalisms. $$$$$ Modularity is achieved through the ability to define primitive templates and lexical rules that are shared among lexical items, as well as by the declarative nature of the grammar formalism itself, removing problems of interaction of rules.
