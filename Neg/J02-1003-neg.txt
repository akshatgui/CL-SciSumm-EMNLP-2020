Therefore, van Deemter (2002) has extended the set of descriptors to boolean combinations of attributes, including negations. $$$$$ To guarantee that a distinguishing description is generated whenever such descriptions exist, the paper proposes generalizations and extensions of the Incremental Algorithm of Dale and Reiter (1995).
Therefore, van Deemter (2002) has extended the set of descriptors to boolean combinations of attributes, including negations. $$$$$ For example, the property BUD is rejected because it does not remove any distractors.
Therefore, van Deemter (2002) has extended the set of descriptors to boolean combinations of attributes, including negations. $$$$$ We first present a version that focuses on properties, without separating these into Attributes and Values, and assume the properties themselves are ordered in a list P (cf.
Therefore, van Deemter (2002) has extended the set of descriptors to boolean combinations of attributes, including negations. $$$$$ To guarantee that a distinguishing description is generated whenever such descriptions exist, the paper proposes generalizations and extensions of the Incremental

Recent extensions address some of its shortcomings, such as negated and disjoined properties (van Deemter, 2002) and an account of salience for generating contextually appropriate shorter REs (Krahmer and Theune, 2002). $$$$$ After studying references to individual objects, we discuss references to sets, including Boolean descriptions that make use of negated and disjoined properties.
Recent extensions address some of its shortcomings, such as negated and disjoined properties (van Deemter, 2002) and an account of salience for generating contextually appropriate shorter REs (Krahmer and Theune, 2002). $$$$$ After studying references to individual objects, we discuss references to sets, including Boolean descriptions that make use of negated and disjoined properties.
Recent extensions address some of its shortcomings, such as negated and disjoined properties (van Deemter, 2002) and an account of salience for generating contextually appropriate shorter REs (Krahmer and Theune, 2002). $$$$$ This paper brings a logical perspective to the generation of referring expressions, addressing the incompleteness of existing algorithms in this area.
Recent extensions address some of its shortcomings, such as negated and disjoined properties (van Deemter, 2002) and an account of salience for generating contextually appropriate shorter REs (Krahmer and Theune, 2002). $$$$$ We take the Incremental Algorithm (Dale and Reiter 1995) to represent the state of the art in this area, and we minimize the deviations from this algorithm.

The Context-Sensitive extension (Krahmer and Theune, 2002) is able to generate referring expressions for the most salient entity in a context; the Boolean Expressions algorithm (van Deemter, 2002) is able to derive expressions containing boolean operators, as in the cup that does not have a handle; and the Sets algorithm (van Deemter, 2002) extends the basic approach to references to sets, as in the red cups. $$$$$ Examples of this kind suggest that GRE should also take the computational complexity of interpretation into account.
The Context-Sensitive extension (Krahmer and Theune, 2002) is able to generate referring expressions for the most salient entity in a context; the Boolean Expressions algorithm (van Deemter, 2002) is able to derive expressions containing boolean operators, as in the cup that does not have a handle; and the Sets algorithm (van Deemter, 2002) extends the basic approach to references to sets, as in the red cups. $$$$$ Like D&R, D&RAtt has linear complexity.
The Context-Sensitive extension (Krahmer and Theune, 2002) is able to generate referring expressions for the most salient entity in a context; the Boolean Expressions algorithm (van Deemter, 2002) is able to derive expressions containing boolean operators, as in the cup that does not have a handle; and the Sets algorithm (van Deemter, 2002) extends the basic approach to references to sets, as in the red cups. $$$$$ These assumptions are harmless in connection with present NLG systems, all of which work with relatively small sets.
The Context-Sensitive extension (Krahmer and Theune, 2002) is able to generate referring expressions for the most salient entity in a context; the Boolean Expressions algorithm (van Deemter, 2002) is able to derive expressions containing boolean operators, as in the cup that does not have a handle; and the Sets algorithm (van Deemter, 2002) extends the basic approach to references to sets, as in the red cups. $$$$$ Reiter and Dale 2000).

Recently, algorithms have been applied to the identification of sets of objects rather than individuals [Bateman 1999, Stone 2000, Krahmer, v. Erk, and Verweg 2001], and the repertoire of descriptions has been extended to boolean combinations of attributes, including negations [van Deemter 2002]. $$$$$ There is no backtracking.
Recently, algorithms have been applied to the identification of sets of objects rather than individuals [Bateman 1999, Stone 2000, Krahmer, v. Erk, and Verweg 2001], and the repertoire of descriptions has been extended to boolean combinations of attributes, including negations [van Deemter 2002]. $$$$$ The present paper will focus on another approach to Boolean descriptions, which takes the Incremental Algorithm as its point of departure (van Deemter 2001).
Recently, algorithms have been applied to the identification of sets of objects rather than individuals [Bateman 1999, Stone 2000, Krahmer, v. Erk, and Verweg 2001], and the repertoire of descriptions has been extended to boolean combinations of attributes, including negations [van Deemter 2002]. $$$$$ As a result, this paper might be read as an investigation into how widely the ideas underlying the Incremental Algorithm can be used, and the extent to which they may be generalized.
Recently, algorithms have been applied to the identification of sets of objects rather than individuals [Bateman 1999, Stone 2000, Krahmer, v. Erk, and Verweg 2001], and the repertoire of descriptions has been extended to boolean combinations of attributes, including negations [van Deemter 2002]. $$$$$ Analogously, the word description will refer to the semantic content of a linguistic expression only.

This is because these operators appear only in embedded boolean combinations [van Deemter 2002], which are the basis for building larger varieties of expressions [Horacek 2004]. $$$$$ The paper brings a degree of formal precision to this issue and reveals a number of reasons why current GRE algorithms are incomplete; we sketch remedies and discuss their consequences in terms of linguistic coverage and computational tractability.
This is because these operators appear only in embedded boolean combinations [van Deemter 2002], which are the basis for building larger varieties of expressions [Horacek 2004]. $$$$$ Accordingly, when we write Generation of Referring Expressions or GRE, we will refer specifically to determination of the semantic content of a description.
This is because these operators appear only in embedded boolean combinations [van Deemter 2002], which are the basis for building larger varieties of expressions [Horacek 2004]. $$$$$ Once D&RBoolean,Att is constructed along these lines, the question of overlapping Values arises in exactly the same way as in the case of D&RAtt and D&RPlural,Att.

Subsequent work on referring expression generation has expanded the logical framework to allow reference by negation (the dog that is not black) and references to multiple entities (the brown or black dogs) (van Deemter, 2002), explored different search algorithms for finding the minimal description (e.g., Horacek (2003)) and offered different representation frameworks like graph theory (Krahmer et al, 2003) as alternatives to AVMs. $$$$$ Unfortunately, this algorithm becomes intractable if Values overlap too often: in the worst case, we are back to having to check all combinations of properties.
Subsequent work on referring expression generation has expanded the logical framework to allow reference by negation (the dog that is not black) and references to multiple entities (the brown or black dogs) (van Deemter, 2002), explored different search algorithms for finding the minimal description (e.g., Horacek (2003)) and offered different representation frameworks like graph theory (Krahmer et al, 2003) as alternatives to AVMs. $$$$$ A GRE algorithm is successful with respect to a given situation (i.e., with respect to a KB and a target) if it produces a distinguishing description of r in that situation.
Subsequent work on referring expression generation has expanded the logical framework to allow reference by negation (the dog that is not black) and references to multiple entities (the brown or black dogs) (van Deemter, 2002), explored different search algorithms for finding the minimal description (e.g., Horacek (2003)) and offered different representation frameworks like graph theory (Krahmer et al, 2003) as alternatives to AVMs. $$$$$ Integration of these different algorithms into one unified algorithm would be a nontrivial enterprise, as we have shown in Section 4.3.
Subsequent work on referring expression generation has expanded the logical framework to allow reference by negation (the dog that is not black) and references to multiple entities (the brown or black dogs) (van Deemter, 2002), explored different search algorithms for finding the minimal description (e.g., Horacek (2003)) and offered different representation frameworks like graph theory (Krahmer et al, 2003) as alternatives to AVMs. $$$$$ .

Transformation Rules $$$$$ To see this, let Desi be the description that results after processing (i.e., inspecting and possibly including) Qi.
Transformation Rules $$$$$ If nl « na, then this is on the order of nnl a .
Transformation Rules $$$$$ Thanks are due to Robert Dale, Magn´us Halld´orsson, Emiel Krahmer, Paul Piwek, Richard Power, Ehud Reiter, and Matthew Stone for useful discussions.

GRE has been dominated by Dale and Reiter's (1995) Incremental Algorithm (IA), one version of which, generalised to deal with non-disjunctive plural references, is shown in Algorithm 1 (van Deemter, 2002). $$$$$ Thanks are due to Robert Dale, Magn´us Halld´orsson, Emiel Krahmer, Paul Piwek, Richard Power, Ehud Reiter, and Matthew Stone for useful discussions.
GRE has been dominated by Dale and Reiter's (1995) Incremental Algorithm (IA), one version of which, generalised to deal with non-disjunctive plural references, is shown in Algorithm 1 (van Deemter, 2002). $$$$$ Also, we focus on “one shot” descriptions, disregarding cases where an object is described through its relations with other objects (Dale and Haddock 1991; Horacek 1997; Krahmer, van Erk, and Verleg 2001).
GRE has been dominated by Dale and Reiter's (1995) Incremental Algorithm (IA), one version of which, generalised to deal with non-disjunctive plural references, is shown in Algorithm 1 (van Deemter, 2002). $$$$$ Thanks are due to Robert Dale, Magn´us Halld´orsson, Emiel Krahmer, Paul Piwek, Richard Power, Ehud Reiter, and Matthew Stone for useful discussions.
GRE has been dominated by Dale and Reiter's (1995) Incremental Algorithm (IA), one version of which, generalised to deal with non-disjunctive plural references, is shown in Algorithm 1 (van Deemter, 2002). $$$$$ Thanks are due to Robert Dale, Magn´us Halld´orsson, Emiel Krahmer, Paul Piwek, Richard Power, Ehud Reiter, and Matthew Stone for useful discussions.

Such a description would be returned by a generalised version of Algorithm 1 proposed by van Deemter (2002). $$$$$ Thus, to denote Value j of Attribute Ai, we write Vi,j.
Such a description would be returned by a generalised version of Algorithm 1 proposed by van Deemter (2002). $$$$$ In the next two sections, we will investigate how negation and disjunction can be taken into account in GRE.

Unlike van Deemter (2002), we only focus on disjunction, leaving negation aside. $$$$$ Based on these considerations, we prove intersective completeness under some assumptions concerning infinity and overlapping Values.
Unlike van Deemter (2002), we only focus on disjunction, leaving negation aside. $$$$$ Thanks are due to Robert Dale, Magn´us Halld´orsson, Emiel Krahmer, Paul Piwek, Richard Power, Ehud Reiter, and Matthew Stone for useful discussions.
Unlike van Deemter (2002), we only focus on disjunction, leaving negation aside. $$$$$ Consequently, by Assumption (1), Case (ii) implies that [[Vi,a1]] n · · · n [[Vi,an]] n [[Vi,j]] is a real subset of [[Vi,a1]] n · · · n [[Vi,an]] n [[BV ]], contradicting the fact that FindBestValue prefers a more general Value (i.e., BV ) over a more specific one (i.e., Vi,j) only if it removes the same distractors.

Evaluation results showed that these principles are on the right track, with significantly better performance over a previous model (van Deemter, 2002). $$$$$ Helpful comments from the reviewers of Computational Linguistics are also gratefully acknowledged.
Evaluation results showed that these principles are on the right track, with significantly better performance over a previous model (van Deemter, 2002). $$$$$ After studying references to individual objects, we discuss references to sets, including Boolean descriptions that make use of negated and disjoined properties.
Evaluation results showed that these principles are on the right track, with significantly better performance over a previous model (van Deemter, 2002). $$$$$ We first present a version that focuses on properties, without separating these into Attributes and Values, and assume the properties themselves are ordered in a list P (cf.
Evaluation results showed that these principles are on the right track, with significantly better performance over a previous model (van Deemter, 2002). $$$$$ After studying references to individual objects, we discuss references to sets, including Boolean descriptions that make use of negated and disjoined properties.

For instance, the classical Dale and Reiter algorithms compute purely conjunctive formulas; van Deemter (2002) extends this language by adding the other propositional connectives, whereas Dale and Haddock (1991) extends it by allowing existential quantification. $$$$$ This paper brings a logical perspective to the generation of referring expressions, addressing the incompleteness of existing algorithms in this area.
For instance, the classical Dale and Reiter algorithms compute purely conjunctive formulas; van Deemter (2002) extends this language by adding the other propositional connectives, whereas Dale and Haddock (1991) extends it by allowing existential quantification. $$$$$ But r E [[BV]] n [[Vi,j]], so [[BV]] and [[Vi,j]] are not disjoint.
For instance, the classical Dale and Reiter algorithms compute purely conjunctive formulas; van Deemter (2002) extends this language by adding the other propositional connectives, whereas Dale and Haddock (1991) extends it by allowing existential quantification. $$$$$ Success is not always possible: the properties in the KB may not be sufficient for individuating a given object.
For instance, the classical Dale and Reiter algorithms compute purely conjunctive formulas; van Deemter (2002) extends this language by adding the other propositional connectives, whereas Dale and Haddock (1991) extends it by allowing existential quantification. $$$$$ (Desks of types a, b, and e were bought by Philips, and so on.

Although we agree with van Deemter (2002) and others that the careful use of negation and disjunction can improve REs, these connectives must not be overused. $$$$$ In this section, we will show how full Boolean descriptions can be generated.
Although we agree with van Deemter (2002) and others that the careful use of negation and disjunction can improve REs, these connectives must not be overused. $$$$$ In both cases, the description may be useful even though it fails to be distinguishing.
Although we agree with van Deemter (2002) and others that the careful use of negation and disjunction can improve REs, these connectives must not be overused. $$$$$ Helpful comments from the reviewers of Computational Linguistics are also gratefully acknowledged.
Although we agree with van Deemter (2002) and others that the careful use of negation and disjunction can improve REs, these connectives must not be overused. $$$$$ To guarantee that a distinguishing description is generated whenever such descriptions exist, the paper proposes generalizations and extensions of the Incremental

Recently, algorithms have also been developed to the identification of sets of objects rather than individuals (Bateman 1999, Stone 2000, Krahmer, v. Erk, and Verweg 2001), and the repertoire of descriptions has been extended to boolean combinations of attributes, including negations (van Deemter 2002). $$$$$ After studying references to individual objects, we discuss references to sets, including Boolean descriptions that make use of negated and disjoined properties.
Recently, algorithms have also been developed to the identification of sets of objects rather than individuals (Bateman 1999, Stone 2000, Krahmer, v. Erk, and Verweg 2001), and the repertoire of descriptions has been extended to boolean combinations of attributes, including negations (van Deemter 2002). $$$$$ To guarantee that a distinguishing description is generated whenever such descriptions exist, the paper proposes generalizations and extensions of the Incremental Algorithm of Dale and Reiter (1995).
Recently, algorithms have also been developed to the identification of sets of objects rather than individuals (Bateman 1999, Stone 2000, Krahmer, v. Erk, and Verweg 2001), and the repertoire of descriptions has been extended to boolean combinations of attributes, including negations (van Deemter 2002). $$$$$ Such generalizations are natural because the properties involved are implicitly present in the KB, as we will explain; they become especially relevant when the algorithms are also generalized to generate references to sets, rather than individual objects.
Recently, algorithms have also been developed to the identification of sets of objects rather than individuals (Bateman 1999, Stone 2000, Krahmer, v. Erk, and Verweg 2001), and the repertoire of descriptions has been extended to boolean combinations of attributes, including negations (van Deemter 2002). $$$$$ The algorithm can, however, be generalized to cover such cases if we initialize C not to D but to the powerset of D, after which the algorithm selects properties of sets, removing from P(D) all those sets for which the property is false.

An exception to this method is the work by Paraboni and van Deemter (2002) who use hierarchical object representations to refer to parts of a book (figures, sections., etc.). $$$$$ As a result, this paper might be read as an investigation into how widely the ideas underlying the Incremental Algorithm can be used, and the extent to which they may be generalized.
An exception to this method is the work by Paraboni and van Deemter (2002) who use hierarchical object representations to refer to parts of a book (figures, sections., etc.). $$$$$ For instance, if positive literals precede negative literals, the properties relevant for Phase 2 might be ordered as follows: (BUD,BUP,BUW,DUP,DUW,PUW,BUD,BUP,BUW,DUB, DUP,DUW,PUB,PUD,PUW, WUB, WUD, WUP,BUD,BUP, BUW,DUP,DUW,PUW) During Phase 1, no property is selected, since the only property true of all elements in S = {a, b, d, e} is D, which fails to remove any distractors.
An exception to this method is the work by Paraboni and van Deemter (2002) who use hierarchical object representations to refer to parts of a book (figures, sections., etc.). $$$$$ After studying references to individual objects, we discuss references to sets, including Boolean descriptions that make use of negated and disjoined properties.
An exception to this method is the work by Paraboni and van Deemter (2002) who use hierarchical object representations to refer to parts of a book (figures, sections., etc.). $$$$$ In Section 3.3, we proved intersective completeness for two versions of Dale and Reiter’s Incremental Algorithm, D&R and D&RAtt.
