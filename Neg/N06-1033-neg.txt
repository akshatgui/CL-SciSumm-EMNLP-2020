The decoder uses a binarized representation of the rules, which is obtained via a syncronous binarization procedure (Zhang et al., 2006). $$$$$ Each co-indexed child nonterminal pair will be further rewritten as a unit.2 We define the language L(G) produced by an SCFG G as the pairs of terminal strings produced by rewriting exhaustively from the start symbol.
The decoder uses a binarized representation of the rules, which is obtained via a syncronous binarization procedure (Zhang et al., 2006). $$$$$ However, in the source-channel approach to machine translation, we need to combine probabilities from the translation model (an SCFG) with the language model (an ngram), which has been shown to be very important for translation quality (Chiang, 2005).
The decoder uses a binarized representation of the rules, which is obtained via a syncronous binarization procedure (Zhang et al., 2006). $$$$$ In this framework, both alignment (synchronous parsing) and decoding can be thought of as parsing problems, whose complexity is in general exponential in the number of nonterminals on the right hand side of a grammar rule.
The decoder uses a binarized representation of the rules, which is obtained via a syncronous binarization procedure (Zhang et al., 2006). $$$$$ Now the two binarizations have very different effects.

For arbitrary SCFGs, this is typically accomplished via the synchronous binarization technique of (Zhang et al, 2006). $$$$$ 2In making one nonterminal play dual roles, we follow the definitions in (Aho and Ullman, 1972; Chiang, 2005), originally known as Syntax Directed Translation Schema (SDTS).
For arbitrary SCFGs, this is typically accomplished via the synchronous binarization technique of (Zhang et al, 2006). $$$$$ In the first case, we first combine NP with PP: where p and q are the scores of antecedent items.
For arbitrary SCFGs, this is typically accomplished via the synchronous binarization technique of (Zhang et al, 2006). $$$$$ These two binarizations are no different in the translation-model-only decoding described above, just as in monolingual parsing.

We show that this approach gives us better practical performance than a mature system that binarizes using the technique of (Zhang et al, 2006). $$$$$ Modeling reorderings between languages has been a major challenge for machine translation.
We show that this approach gives us better practical performance than a mature system that binarizes using the technique of (Zhang et al, 2006). $$$$$ Figure 7 demonstrates that decoding accuracy is significantly improved after synchronous binarization.
We show that this approach gives us better practical performance than a mature system that binarizes using the technique of (Zhang et al, 2006). $$$$$ The complexity is exponential in the size of individual grammar rules due to arbitrary re-orderings between the two languages, and rules extracted from parallel corpora can be quite large.

For SCFG grammars, (Zhang et al, 2006) provide a scope reduction method called synchronous binarization with quantifiable loss. $$$$$ Here the parallel string pair that we are parsing is the integer sequence (1...n) and its permutation (7r(1)...7r(n)).
For SCFG grammars, (Zhang et al, 2006) provide a scope reduction method called synchronous binarization with quantifiable loss. $$$$$ 4) for other details.
For SCFG grammars, (Zhang et al, 2006) provide a scope reduction method called synchronous binarization with quantifiable loss. $$$$$ The authors wish to thank Wei Wang, Jonathan Graehl and Steven DeNeefe for help with the experiments.

Their principal objective is to provide a scope reduction method for SCFG that introduces fewer postconditions than (Zhang et al, 2006). $$$$$ Below is a simple example: it into a linear-time shift-reduce algorithm that only needs one pass through the sequence.
Their principal objective is to provide a scope reduction method for SCFG that introduces fewer postconditions than (Zhang et al, 2006). $$$$$ We also define an SCFG rule as n-ary if its permutation is of n and call an SCFG n-ary if its longest rule is n-ary.
Their principal objective is to provide a scope reduction method for SCFG that introduces fewer postconditions than (Zhang et al, 2006). $$$$$ Each rule (synchronous production) rewrites a nonterminal in two dimensions subject to the constraint that the sequence of nonterminal children on one side is a permutation of the nonterminal sequence on the other side.
Their principal objective is to provide a scope reduction method for SCFG that introduces fewer postconditions than (Zhang et al, 2006). $$$$$ Shapiro and Stephens (1991, p. 277) informally present an iterative procedure where in each pass it scans the permuted sequence from left to right and combines two adjacent sub sequences whenever possible.

However unlike (Zhang et al, 2006), their method only addresses simple grammars. $$$$$ The decoder now works on the binary translation rules supplied by an external synchronous binarizer.

Binarizing the grammars (Zhang et al, 2006) further increases the size of these sets, due to the introduction of virtual nonterminals. $$$$$ As special cases, single numbers are permuted sequences as well.
Binarizing the grammars (Zhang et al, 2006) further increases the size of these sets, due to the introduction of virtual nonterminals. $$$$$ 4) that the percentage of binarizable cases over all permutations of length n quickly approaches 0 as n grows (see Figure 6).
Binarizing the grammars (Zhang et al, 2006) further increases the size of these sets, due to the introduction of virtual nonterminals. $$$$$ We devise a linear-time algorithm for factoring syntactic re-orderings by binarizing synchronous rules when possible and show that the resulting rule set significantly improves the speed and accuracy of a state-of-the-art syntax-based machine translation system.

Rule size and lexicalization affect parsing complexity whether the grammar is binarized explicitly (Zhang et al, 2006) or implicitly binarized using Early-style intermediate symbols (Zollmann et al, 2006). $$$$$ • We examine cases of non-binarizable rules in a large, empirically-derived rule set, and we investigate the effect on translation quality when excluding such rules.
Rule size and lexicalization affect parsing complexity whether the grammar is binarized explicitly (Zhang et al, 2006) or implicitly binarized using Early-style intermediate symbols (Zollmann et al, 2006). $$$$$ For example, we could binarize the first rule left to right or right to left:
Rule size and lexicalization affect parsing complexity whether the grammar is binarized explicitly (Zhang et al, 2006) or implicitly binarized using Early-style intermediate symbols (Zollmann et al, 2006). $$$$$ Modeling reorderings between languages has been a major challenge for machine translation.

Synchronous binarization (Zhang et al, 2006) solves this problem by simultaneously binarizing both source and target-sides of a synchronous rule, making sure of contiguous spans on both sides whenever possible. $$$$$ An alternative definition by Satta and Peserico (2005) allows co-indexed nonterminals taking different symbols in two dimensions.
Synchronous binarization (Zhang et al, 2006) solves this problem by simultaneously binarizing both source and target-sides of a synchronous rule, making sure of contiguous spans on both sides whenever possible. $$$$$ We denote the class of binarizable SCFGs as bSCFG.
Synchronous binarization (Zhang et al, 2006) solves this problem by simultaneously binarizing both source and target-sides of a synchronous rule, making sure of contiguous spans on both sides whenever possible. $$$$$ In contrast, the rule extraction method of Galley et al. (2004) aims to incorporate more syntactic information by providing parse trees for the target language and extracting tree transducer rules that apply to the parses.
Synchronous binarization (Zhang et al, 2006) solves this problem by simultaneously binarizing both source and target-sides of a synchronous rule, making sure of contiguous spans on both sides whenever possible. $$$$$ VPP-VP) virtual nonterminals and corresponding rules virtual rules, whose probabilities are all set to 1.

Intuitively speaking, the gaps on the target-side will lead to exponential complexity in decoding with integrated language models (see Section 3), as well as synchronous parsing (Zhang et al, 2006). $$$$$ As special cases, single numbers are permuted sequences as well.
Intuitively speaking, the gaps on the target-side will lead to exponential complexity in decoding with integrated language models (see Section 3), as well as synchronous parsing (Zhang et al, 2006). $$$$$ Later we add Pr(held  |Powell) when the resulting item is combined with � Powell ��� Powell form an S item.
Intuitively speaking, the gaps on the target-side will lead to exponential complexity in decoding with integrated language models (see Section 3), as well as synchronous parsing (Zhang et al, 2006). $$$$$ From a synchronous rewriting point of view, this is more akin to synchronous tree substitution grammar (STSG) (Eisner, 2003).
Intuitively speaking, the gaps on the target-side will lead to exponential complexity in decoding with integrated language models (see Section 3), as well as synchronous parsing (Zhang et al, 2006). $$$$$ To do bigram-integrated decoding, we need to augment each chart item (X, i, j) with two target-language boundary words u and v to produce a bigram-item like u X v \ , following the dynamic program(i j ming algorithm of Wu (1996).

This representation, being contiguous on both sides, successfully reduces the decoding complexity to a low polynomial and significantly improved the search quality (Zhang et al, 2006). $$$$$ Each binarizable permuted sequence has at least one hierarchical binarization pattern.
This representation, being contiguous on both sides, successfully reduces the decoding complexity to a low polynomial and significantly improved the search quality (Zhang et al, 2006). $$$$$ From a modeling perspective, on the other hand, it is beneficial to start with a richer representation that has more transformational power than ITG or binary SCFG.
This representation, being contiguous on both sides, successfully reduces the decoding complexity to a low polynomial and significantly improved the search quality (Zhang et al, 2006). $$$$$ Our work shows how to convert it back to a computationally friendly form without harming much of its expressiveness.
This representation, being contiguous on both sides, successfully reduces the decoding complexity to a low polynomial and significantly improved the search quality (Zhang et al, 2006). $$$$$ Systems based on synchronous grammars and tree transducers promise to improve the quality of statistical machine translation output, but are often very computationally intensive.

Although according to Zhang et al (2006), the vast majority (99.7%) of rules in their Chinese-English dataset are binarizable, there do exist some interesting cases that are not (see Figure 2 for a real-data example). $$$$$ VPP-VP) virtual nonterminals and corresponding rules virtual rules, whose probabilities are all set to 1.
Although according to Zhang et al (2006), the vast majority (99.7%) of rules in their Chinese-English dataset are binarizable, there do exist some interesting cases that are not (see Figure 2 for a real-data example). $$$$$ In this framework, both alignment (synchronous parsing) and decoding can be thought of as parsing problems, whose complexity is in general exponential in the number of nonterminals on the right hand side of a grammar rule.
Although according to Zhang et al (2006), the vast majority (99.7%) of rules in their Chinese-English dataset are binarizable, there do exist some interesting cases that are not (see Figure 2 for a real-data example). $$$$$ Our system has a promising improvement over the ATS system which is trained on a larger data-set but tuned independently.
Although according to Zhang et al (2006), the vast majority (99.7%) of rules in their Chinese-English dataset are binarizable, there do exist some interesting cases that are not (see Figure 2 for a real-data example). $$$$$ Melamed (2003) discusses binarization of multitext grammars on a theoretical level, showing the importance and difficulty of binarization for efficient synchronous parsing.

We used a bottom-up, CKY-style decoder that works with binary xRs rules obtained via a synchronous binarization procedure (Zhang et al, 2006). $$$$$ However, in the source-channel approach to machine translation, we need to combine probabilities from the translation model (an SCFG) with the language model (an ngram), which has been shown to be very important for translation quality (Chiang, 2005).
We used a bottom-up, CKY-style decoder that works with binary xRs rules obtained via a synchronous binarization procedure (Zhang et al, 2006). $$$$$ The only extra work we need to do for decoding is to build corresponding target-language (English) subtrees in parallel.
We used a bottom-up, CKY-style decoder that works with binary xRs rules obtained via a synchronous binarization procedure (Zhang et al, 2006). $$$$$ From a modeling perspective, on the other hand, it is beneficial to start with a richer representation that has more transformational power than ITG or binary SCFG.
We used a bottom-up, CKY-style decoder that works with binary xRs rules obtained via a synchronous binarization procedure (Zhang et al, 2006). $$$$$ Once we decompose the permutation of n in the original rule into binary permutations, all that remains is to decorate the skeleton binary parse with nonterminal symbols and attach terminals to the skeleton appropriately.

Most practical non-binary SCFGs can be binarized using the synchronous binarization technique by Zhang et al (2006). $$$$$ Instead, we have to maintain all four boundary words (rather than two) and postpone the language model scoring till the next step where VNP-PP is combined with C held ··· meeting l /I to form an S item.
Most practical non-binary SCFGs can be binarized using the synchronous binarization technique by Zhang et al (2006). $$$$$ In other words, targetlanguage boundary words from each child nonterminal of the rule will be cached in all virtual nonterminals derived from this rule.
Most practical non-binary SCFGs can be binarized using the synchronous binarization technique by Zhang et al (2006). $$$$$ • We examine cases of non-binarizable rules in a large, empirically-derived rule set, and we investigate the effect on translation quality when excluding such rules.

Zhang et al (2006) discuss methods for binarizing SCFGs, ignoring the nonbinarizable grammars. $$$$$ This work was partially supported by NSF ITR IIS-09325646 and NSF ITR IIS-0428020.
Zhang et al (2006) discuss methods for binarizing SCFGs, ignoring the nonbinarizable grammars. $$$$$ As shown in Section 1, decoding complexity with this method is exponential in the size of the longest rule and since we postpone all the language model scorings, pruning in this case is also biased. system bleu monolingual binarization 36.25 synchronous binarization 38.44 To move on to synchronous binarization, we first did an experiment using the above baseline system without the 0.3% non-binarizable rules and did not observe any difference in BLEU scores.
Zhang et al (2006) discuss methods for binarizing SCFGs, ignoring the nonbinarizable grammars. $$$$$ However, for machine translation, it is more meaningful to compute the ratio of binarizable rules extracted from real text.
Zhang et al (2006) discuss methods for binarizing SCFGs, ignoring the nonbinarizable grammars. $$$$$ We explain the technical details in the next section.

A CYK-style decoder has to rely on binarization to preprocess the grammar as did in (Zhang et al, 2006) to handle multi-nonterminal rules. $$$$$ We compare the two binarization schemes in terms of translation quality with various pruning thresholds.
A CYK-style decoder has to rely on binarization to preprocess the grammar as did in (Zhang et al, 2006) to handle multi-nonterminal rules. $$$$$ We did a “spectrum analysis” on the resulting rule set with 50,879,242 rules.
A CYK-style decoder has to rely on binarization to preprocess the grammar as did in (Zhang et al, 2006) to handle multi-nonterminal rules. $$$$$ This system can model nonisomorphic transformations on English parse trees to “fit” another language, for example, learning that the (S (V O)) structure in English should be transformed into a (V S O) structure in Arabic, by looking at two-level tree fragments (Knight and Graehl, 2005).
A CYK-style decoder has to rely on binarization to preprocess the grammar as did in (Zhang et al, 2006) to handle multi-nonterminal rules. $$$$$ Our system is consistently faster and more accurate than the baseline system.

Many solutions to the reordering problem have been proposed, e.g. syntax-based models (Chiang, 2005), lexicalized reordering (Och et al, 2004), and tree-to-string methods (Zhang et al, 2006). $$$$$ We devise a linear-time algorithm for factoring syntactic re-orderings by binarizing synchronous rules when possible and show that the resulting rule set significantly improves the speed and accuracy of a state-of-the-art syntax-based machine translation system.
Many solutions to the reordering problem have been proposed, e.g. syntax-based models (Chiang, 2005), lexicalized reordering (Och et al, 2004), and tree-to-string methods (Zhang et al, 2006). $$$$$ Figure 6 shows how the rules are distributed against their lengths (number of nonterminals).
Many solutions to the reordering problem have been proposed, e.g. syntax-based models (Chiang, 2005), lexicalized reordering (Och et al, 2004), and tree-to-string methods (Zhang et al, 2006). $$$$$ Overall, 99.7% of the rules are binarizable.
Many solutions to the reordering problem have been proposed, e.g. syntax-based models (Chiang, 2005), lexicalized reordering (Och et al, 2004), and tree-to-string methods (Zhang et al, 2006). $$$$$ Aggressive pruning must be used to make it tractable in practice, which in general introduces many search errors and adversely affects translation quality.

Compared with its string-based counterparts, tree-based decoding is simpler and faster: there is no need for synchronous binarization (Huang et al, 2009b; Zhang et al, 2006) and tree parsing generally runs in linear time (Huang et al, 2006). $$$$$ 7) introduces a non-ambiguous ITG that prefers left-heavy binary trees so that for each permutation there is a unique synchronous derivation (binarization pattern).
Compared with its string-based counterparts, tree-based decoding is simpler and faster: there is no need for synchronous binarization (Huang et al, 2009b; Zhang et al, 2006) and tree parsing generally runs in linear time (Huang et al, 2006). $$$$$ The authors wish to thank Wei Wang, Jonathan Graehl and Steven DeNeefe for help with the experiments.
Compared with its string-based counterparts, tree-based decoding is simpler and faster: there is no need for synchronous binarization (Huang et al, 2009b; Zhang et al, 2006) and tree parsing generally runs in linear time (Huang et al, 2006). $$$$$ Later we add Pr(held  |Powell) when the resulting item is combined with � Powell ��� Powell form an S item.

As tree-to-string rules usually have multiple non-terminals that make decoding complexity generally exponential, synchronous binarization (Huang et al, 2009b; Zhang et al, 2006) is a key technique for applying the CKY algorithm to parsing with tree-to-string rules. $$$$$ Our system is consistently faster and more accurate than the baseline system.
As tree-to-string rules usually have multiple non-terminals that make decoding complexity generally exponential, synchronous binarization (Huang et al, 2009b; Zhang et al, 2006) is a key technique for applying the CKY algorithm to parsing with tree-to-string rules. $$$$$ We devise a linear-time algorithm for factoring syntactic re-orderings by binarizing synchronous rules when possible and show that the resulting rule set significantly improves the speed and accuracy of a state-of-the-art syntax-based machine translation system.
As tree-to-string rules usually have multiple non-terminals that make decoding complexity generally exponential, synchronous binarization (Huang et al, 2009b; Zhang et al, 2006) is a key technique for applying the CKY algorithm to parsing with tree-to-string rules. $$$$$ This work shows that the majority of syntactic reorderings, at least between languages like English and Chinese, can be efficiently decomposed into hierarchical binary reorderings.
As tree-to-string rules usually have multiple non-terminals that make decoding complexity generally exponential, synchronous binarization (Huang et al, 2009b; Zhang et al, 2006) is a key technique for applying the CKY algorithm to parsing with tree-to-string rules. $$$$$ However, not every SCFG can be binarized.

In our string-to-tree model, for efficient decoding with integrated n-gram LM, we follow (Zhang et al, 2006) and inversely binarize all translation rules into Chomsky Normal Forms that contain at most two variables and can be incrementally scored by LM. $$$$$ Shapiro and Stephens (1991, p. 277) informally present an iterative procedure where in each pass it scans the permuted sequence from left to right and combines two adjacent sub sequences whenever possible.
In our string-to-tree model, for efficient decoding with integrated n-gram LM, we follow (Zhang et al, 2006) and inversely binarize all translation rules into Chomsky Normal Forms that contain at most two variables and can be incrementally scored by LM. $$$$$ This situation is unpleasant because in the targetlanguage NP and PP are not contiguous so we cannot apply language model scoring when we build the VNP-PP item.
In our string-to-tree model, for efficient decoding with integrated n-gram LM, we follow (Zhang et al, 2006) and inversely binarize all translation rules into Chomsky Normal Forms that contain at most two variables and can be incrementally scored by LM. $$$$$ The only extra work we need to do for decoding is to build corresponding target-language (English) subtrees in parallel.
In our string-to-tree model, for efficient decoding with integrated n-gram LM, we follow (Zhang et al, 2006) and inversely binarize all translation rules into Chomsky Normal Forms that contain at most two variables and can be incrementally scored by LM. $$$$$ In order to do so we need to keep track of sub-alignments including both aligned nonterminals and neighboring terminals.
