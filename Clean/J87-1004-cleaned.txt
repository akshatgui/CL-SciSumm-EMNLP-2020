 $$$$$ This can be avoided by using a tree-structured stack, which is described in the following subsection.
 $$$$$ Ron Kaplan, Martin Kay, Lauri Karttunen, and Stuart Shieber provided useful comments on the implementation of LFG and dag structure sharing.

Similar to the work of Lang (1974) and Tomita (1987) extending LR parsers for arbitrary CFGs, the LR parsers for TAGs can be extended to solve by pseudo-parallelism the conflicts of moves. $$$$$ The pseudo-parallelism works as follows.
Similar to the work of Lang (1974) and Tomita (1987) extending LR parsers for arbitrary CFGs, the LR parsers for TAGs can be extended to solve by pseudo-parallelism the conflicts of moves. $$$$$ Despite the availability of left-to-right algorithms, surprisingly few on-line parsers exist.

We developed a set of augmented context free grammar rules for general English syntactic analysis and the analyzer is implemented using Tomita LR parsing algorithm (Tomita, 1987). $$$$$ An Efficient Augmented-Context-Free Parsing Algorithm
We developed a set of augmented context free grammar rules for general English syntactic analysis and the analyzer is implemented using Tomita LR parsing algorithm (Tomita, 1987). $$$$$ Thus, morphological rules, as well as syntactic rules, are written in the augmented context-free grammar.

The RASP parser is a generalized LR parser which builds a non-deterministic generalized LALR parse table from the grammar (Tomita, 1987). $$$$$ Figures 2.1 and 2.2 show an example of a non-LR grammar and its parsing table.
The RASP parser is a generalized LR parser which builds a non-deterministic generalized LALR parse table from the grammar (Tomita, 1987). $$$$$ In this paper, however, we describe the algorithm as a generalized LR parsing algorithm only.

a graph-structured stack (Tomita, 1987) was used to efficiently represent ambiguous index operations in a GIG stack. $$$$$ We call this a tree-structured stack.
a graph-structured stack (Tomita, 1987) was used to efficiently represent ambiguous index operations in a GIG stack. $$$$$ However, we do not necessarily have to copy the whole stack: even after different parallel operations on the tree-structured stack, the bottom portion of the stack may remain the same.

A context-free backbone is automatically derived from the unification grammar1 and a generalized or non-deterministic LALR(1) table is constructed from this backbone (Tomita, 1987). $$$$$ The algorithm is a generalized LR parsing algorithm, which precomputes an LR shift-reduce parsing table (possibly with multiple entries) from a given augmented context-free grammar.
A context-free backbone is automatically derived from the unification grammar1 and a generalized or non-deterministic LALR(1) table is constructed from this backbone (Tomita, 1987). $$$$$ The parsing table can be obtained automatically from a context-free phrase structure grammar, using an algorithm first developed by DeRemer (1969, 1971).

The parsers create parse forests (Tomita, 1987) that incorporate subtree sharing (in which identical sub-analyses are shared between differing superordinate analyses) and node packing (where sub analyses covering the same portion of input whose root categories are in a subsumption relationship are merged into a single node). $$$$$ This section describes two techniques for providing an efficient representation: subtree sharing and local ambiguity packing.
The parsers create parse forests (Tomita, 1987) that incorporate subtree sharing (in which identical sub-analyses are shared between differing superordinate analyses) and node packing (where sub analyses covering the same portion of input whose root categories are in a subsumption relationship are merged into a single node). $$$$$ Such a node is called a packed node, and nodes before packing are called subnodes of the packed node.

In this parser, the LALR (1) technique (Aho, Sethi Ullman, 1986) is used, in conjunction with a graph-structured stack (Tomita, 1987), adapting for unification-based parsing Kipps's (1989) Tomita-like recogniser that achieves polynomial complexity on input length through caching. $$$$$ The exact definition and operation of the LR parser can be found in Aho and Ullman (1977).
In this parser, the LALR (1) technique (Aho, Sethi Ullman, 1986) is used, in conjunction with a graph-structured stack (Tomita, 1987), adapting for unification-based parsing Kipps's (1989) Tomita-like recogniser that achieves polynomial complexity on input length through caching. $$$$$ It is easy to show that the algorithm with the graph-structured stack does not parse any part of an input sentence more than once in the same way.

A forest (Tomita, 1987) compactly encodes an exponential number of parse trees. $$$$$ Section 3 describes how to represent parse trees efficiently, so that all possible parse trees (the parse forest) take at most polynomial space as the ambiguity of a sentence grows exponentially.
A forest (Tomita, 1987) compactly encodes an exponential number of parse trees. $$$$$ Thus, one might notice that, even with an efficient parsing algorithm such as the one we described, the parser would take exponential time because exponential time would be required merely to print out all parse trees (parse forest).
