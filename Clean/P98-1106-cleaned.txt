It is possible to obtain a polynomial parser provided that we limit the number of nodes simultaneously involved in non-projective configurations (see Kahane et al 1998 for similar techniques). $$$$$ If there is no restriction on the lifting, the previous definition is not very interesting since we can in fact take any non-projective tree and lift all nodes to the root node and obtain a projective tree.
It is possible to obtain a polynomial parser provided that we limit the number of nodes simultaneously involved in non-projective configurations (see Kahane et al 1998 for similar techniques). $$$$$ (No other options are possible.)

This formalism is based on previous work presented in (Kahane et al, 1998), which has been substantially reformulated in order to simplify it. $$$$$ In Section 4, we extend this formalism to handle pseudo-projectivity.
This formalism is based on previous work presented in (Kahane et al, 1998), which has been substantially reformulated in order to simplify it. $$$$$ For a model of a DG based on tree-rewriting (in the spirit of Tree Adjoining Grammar (Joshi et al., 1975)), see (Nasr, 1995).

We will extend our basic approach in the spirit of (Kahane et al, 1998) in future work. $$$$$ In Section 4, we extend this formalism to handle pseudo-projectivity.
We will extend our basic approach in the spirit of (Kahane et al, 1998) in future work. $$$$$ For a model of a DG based on tree-rewriting (in the spirit of Tree Adjoining Grammar (Joshi et al., 1975)), see (Nasr, 1995).

Kahane et al (1998) present three different types of rules, for sub categorization, modification, and linear precedence. $$$$$ It can be noted that this domain of locality is equal to the domain of locality of sub-categorization rules.
Kahane et al (1998) present three different types of rules, for sub categorization, modification, and linear precedence. $$$$$ The dependency rules are further subdivided into subcategorization rules (or s-rules) and modification rules (or m-rules).

It is also related to the lifting rules of (Kahane et al, 1998), but where they choose to stipulate rules that license liftings, we opt instead for placing constraints on otherwise unrestricted climbing. $$$$$ We will therefore constrain the lifting by a set of rules, called lifting rules.
It is also related to the lifting rules of (Kahane et al, 1998), but where they choose to stipulate rules that license liftings, we opt instead for placing constraints on otherwise unrestricted climbing. $$$$$ The dependency rules are further subdivided into subcategorization rules (or s-rules) and modification rules (or m-rules).

The pseudo-projective grammar proposed by Kahane et al (1998) can be parsed in polynomial time and captures non-local dependencies through a form of gap-threading, but the structures generated by the grammar are strictly projective. $$$$$ Pseudo-Projectivity A Polynomially Parsable Non-Projective Dependency Grammar
The pseudo-projective grammar proposed by Kahane et al (1998) can be parsed in polynomial time and captures non-local dependencies through a form of gap-threading, but the structures generated by the grammar are strictly projective. $$$$$ The non projective structures found in linguistics represent a small subset of the potential non projective structures.

With this conversion technique, output dependency trees are necessarily projective, and extracted dependencies are necessarily local to a phrase, which means that the automatically converted trees can be regarded as pseudo-projective approximations to the correct dependency trees (Kahane et al, 1998). $$$$$ Although most linguistic structures can be represented as projective trees, it is well known that projectivity is too strong a constraint for dependency trees, as shown by the example of Figure 2, which includes a non-projective arc (marked with a star).
With this conversion technique, output dependency trees are necessarily projective, and extracted dependencies are necessarily local to a phrase, which means that the automatically converted trees can be regarded as pseudo-projective approximations to the correct dependency trees (Kahane et al, 1998). $$$$$ In order to define pseudo-projectivity, we introduce an operation on dependency trees called lifting.

This concept was introduced as lifting in (Kahane et al, 1998). $$$$$ The regular expression representing the lifting condition is enriched with a dot separating, on its left, the part of the lifting path which has already been introduced during the rewriting and on its right the part which is still to be introduced for the rewriting to be valid.
This concept was introduced as lifting in (Kahane et al, 1998). $$$$$ The situation of the dot at the right of the lifting condition indicates that C has been introduced by its syntactic governor although it has already been introduced by its linear governor earlier in the rewriting process.

based: for example, those described by Lombardoand Lesmo (1996), Barbero et al (1998) and Kahane et al (1998) are tied to the formalizations of dependency grammar using context-free like rules described by Hays (1964) and Gaifman (1965). $$$$$ For example: 3We follow (Gaifman, 1965) throughout this paper by modeling a dependency grammar with a string-rewriting system.
based: for example, those described by Lombardoand Lesmo (1996), Barbero et al (1998) and Kahane et al (1998) are tied to the formalizations of dependency grammar using context-free like rules described by Hays (1964) and Gaifman (1965). $$$$$ For a model of a DG based on tree-rewriting (in the spirit of Tree Adjoining Grammar (Joshi et al., 1975)), see (Nasr, 1995).

However, predictive grammar-based algorithms such as those of Lombardo and Lesmo (1996) and Kahane et al (1998) have operations which postulate rules and can not be defined in terms of dependency graphs, since they do not do any modifications to the graph. $$$$$ The dependency rules are further subdivided into subcategorization rules (or s-rules) and modification rules (or m-rules).
However, predictive grammar-based algorithms such as those of Lombardo and Lesmo (1996) and Kahane et al (1998) have operations which postulate rules and can not be defined in terms of dependency graphs, since they do not do any modifications to the graph. $$$$$ For a model of a DG based on tree-rewriting (in the spirit of Tree Adjoining Grammar (Joshi et al., 1975)), see (Nasr, 1995).

In addition, the work of Kahane et al (1998) provides a polynomial parsing algorithm for a constrained class of non projective structures. $$$$$ Although most linguistic structures can be represented as projective trees, it is well known that projectivity is too strong a constraint for dependency trees, as shown by the example of Figure 2, which includes a non-projective arc (marked with a star).
In addition, the work of Kahane et al (1998) provides a polynomial parsing algorithm for a constrained class of non projective structures. $$$$$ The non projective structures found in linguistics represent a small subset of the potential non projective structures.

The definition of non-projectivity can be found in Kahane et al (1998). $$$$$ Pseudo-Projectivity A Polynomially Parsable Non-Projective Dependency Grammar
The definition of non-projectivity can be found in Kahane et al (1998). $$$$$ The definition given here is borrowed from (Marcus, 1965) and (Robinson, 1970): Definition: An arc t- is projective if and only if for every y covered by y x+ .

 $$$$$ Every set of lifting rules defines a particular property of pseudo-projectivity by imposing particular constraints on the lifting.
 $$$$$ The time complexity of the algorithm is therefore 0(GQn3+2ILI).

First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al, 1998) and encoding information about these lifts in arc labels. $$$$$ We can extend the bottom-up parser for GDG to a parser for PP-GDG in the following manner.
First, the training data for the parser is projectivized by applying a minimal number of lifting operations (Kahane et al, 1998) and encoding information about these lifts in arc labels. $$$$$ The maximum number of entries in each square of the parse matrix is 0(GQ4), where G is the number of rule-FSMs corresponding to LP rules in the grammar, Q is the maximum number of states in any of the rule-FSMs, and L is the maximum number of states that the lifting rules can be in (i.e., the number of lifting conditions in the grammar multiplied by the maximum number of dot positions of any lifting condition).

We call this pseudo projective dependency parsing, since it is based on a notion of pseudo-projectivity (Kahane et al, 1998). $$$$$ Pseudo-Projectivity A Polynomially Parsable Non-Projective Dependency Grammar
We call this pseudo projective dependency parsing, since it is based on a notion of pseudo-projectivity (Kahane et al, 1998). $$$$$ In order to define pseudo-projectivity, we introduce an operation on dependency trees called lifting.

The dependency graph in Figure 1 satisfies all the defining conditions above, but it fails to satisfy the condition of projectivity (Kahane et al, 1998). $$$$$ Although most linguistic structures can be represented as projective trees, it is well known that projectivity is too strong a constraint for dependency trees, as shown by the example of Figure 2, which includes a non-projective arc (marked with a star).
The dependency graph in Figure 1 satisfies all the defining conditions above, but it fails to satisfy the condition of projectivity (Kahane et al, 1998). $$$$$ If, after the above repositioning of the dot and the linking up of all linear dependents to lifting conditions, there are still lifting conditions in LM such that the dot is at the beginning of the lifting condition, then no new entry is made in the parse matrix for n. 4.

Using the terminology of Kahane et al (1998), we say that jedna is the syntactic head of Z, while je is its linear head in the projectivized representation. $$$$$ We will say that the node x has been lifted from X+T (its syntactic governor) to X+Ti (its linear governor).
Using the terminology of Kahane et al (1998), we say that jedna is the syntactic head of Z, while je is its linear head in the projectivized representation. $$$$$ In order to capture pseudo-projectivity, we will interpret rules of the form (2) (for subcategorization of arguments by a head) and (4) (for selection of a head by an adjunct) as introducing syntactic dependents which may lift to a higher linear governor.

Unlike Kahane et al (1998), we do not regard a projectivized representation as the final target of the parsing process. $$$$$ A sample derivation is shown in Figure 3, with the sentential form representation on top and the corresponding tree representation below.
Unlike Kahane et al (1998), we do not regard a projectivized representation as the final target of the parsing process. $$$$$ A sample derivation is shown in Figure 4, with the sentential form representation on top and the corresponding tree representation below.
