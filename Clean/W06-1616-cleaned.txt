For dependency parsing, McDonald and Pereira (2006) proposed a method which can incorporate some types of global features, and Riedel and Clarke (2006) studied a method using integer linear programming which can incorporate global linguistic constraints. $$$$$ The method we present is not the only one that can take global constraints into account.
For dependency parsing, McDonald and Pereira (2006) proposed a method which can incorporate some types of global features, and Riedel and Clarke (2006) studied a method using integer linear programming which can incorporate global linguistic constraints. $$$$$ We alleviate this problem by presenting an equivalent Integer Linear Programming formulation which allows us to incorporate global constraints naturally.

However, work in dependency parsing (Riedel and Clarke, 2006) has demonstrated that it is possible to use ILP to perform efficient inference for very large programs when used in an incremental manner. $$$$$ Incremental Integer Linear Programming For Non-Projective Dependency Parsing
However, work in dependency parsing (Riedel and Clarke, 2006) has demonstrated that it is possible to use ILP to perform efficient inference for very large programs when used in an incremental manner. $$$$$ However, it is not possible to use this approach directly for a complex task like non-projective dependency parsing due to the exponential number of constraints required to prevent cycles occurring in the dependency graph.

However, recent work (Riedel and Clarke, 2006) has shown that even exponentially large decoding problems may be solved efficiently using ILP solvers if a Cutting-Plane Algorithm (Dantzig et al, 1954) is used. $$$$$ To model all these constraints explicitly would result in an ILP formulation too large to solve efficiently (Williams, 2002).
However, recent work (Riedel and Clarke, 2006) has shown that even exponentially large decoding problems may be solved efficiently using ILP solvers if a Cutting-Plane Algorithm (Dantzig et al, 1954) is used. $$$$$ While we expect a longer runtime than using the Chu-Liu-Edmonds as in previous work (McDonald et al., 2005b), we are interested in how large the increase is.

Riedel and Clarke (2006) describe ILP methods for the problem; Martins et al (2009) recently introduced alternative LP and ILP formulations. $$$$$ A similar problem also occurs in an ILP formulation for machine translation which treats decoding as the Travelling Salesman Problem (Germann et al., 2001).
Riedel and Clarke (2006) describe ILP methods for the problem; Martins et al (2009) recently introduced alternative LP and ILP formulations. $$$$$ This is not the case when using ILP.

Riedel and Clarke (2006) tackled the MAP problem for dependency parsing by an incremental approach that starts with a relaxation of the problem, solves it, and adds additional constraints only if they are violated. $$$$$ We present an approach which solves the problem incrementally, thus we avoid creating intractable integer linear programs.
Riedel and Clarke (2006) tackled the MAP problem for dependency parsing by an incremental approach that starts with a relaxation of the problem, solves it, and adds additional constraints only if they are violated. $$$$$ As a workaround for this problem we follow an incremental approach akin to the work of Warme (1998).

ILPs have since been used successfully in many NLP applications involving complex structures Punyakanok et al (2008) for semantic role labeling, Riedel and Clarke (2006) and Martins et al (2009) for dependency parsing and several others. $$$$$ Strong assumptions are also made in the case of McDonald et al.’s (2005b) non-projective dependency parsing model.
ILPs have since been used successfully in many NLP applications involving complex structures Punyakanok et al (2008) for semantic role labeling, Riedel and Clarke (2006) and Martins et al (2009) for dependency parsing and several others. $$$$$ Although less informative than lexicalised phrase structures, dependency structures still capture most of the predicate-argument information needed for applications.

Another attempt to overcome the problem of complexity with ILP models is described in (Riedel and Clarke, 2006) (dependency parsing). $$$$$ A similar problem also occurs in an ILP formulation for machine translation which treats decoding as the Travelling Salesman Problem (Germann et al., 2001).
Another attempt to overcome the problem of complexity with ILP models is described in (Riedel and Clarke, 2006) (dependency parsing). $$$$$ We found out experimentally that dependency parsing models of this form do not converge on a solution after multiple hours of solving, even for small sentences.

In contrast, generic NP-hard solution techniques like Integer Linear Programming (Riedel and Clarke, 2006) know nothing about optimal substructure. $$$$$ Incremental Integer Linear Programming For Non-Projective Dependency Parsing
In contrast, generic NP-hard solution techniques like Integer Linear Programming (Riedel and Clarke, 2006) know nothing about optimal substructure. $$$$$ Integer Linear Programming is an extension of linear programming where all decision variables must take integer values.

Riedel and Clarke (2006) showed that dependency parsing can be framed as Integer Linear Program (ILP), and efficiently solved using an off-the shelf optimizer if a cutting plane approach is used. $$$$$ Incremental Integer Linear Programming For Non-Projective Dependency Parsing
Riedel and Clarke (2006) showed that dependency parsing can be framed as Integer Linear Program (ILP), and efficiently solved using an off-the shelf optimizer if a cutting plane approach is used. $$$$$ While previous approaches which use ILP for decoding have solved each integer linear program in one run, we incrementally add constraints and solve the resulting program until no more constraints are violated.

Compared to the representation Riedel and Clarke (2006), this bound has the benefit a small polynomial number of constraints. $$$$$ Also, only a small number of sentences take longer than two minutes to parse.
Compared to the representation Riedel and Clarke (2006), this bound has the benefit a small polynomial number of constraints. $$$$$ Thus other applications may benefit from it.

Our formulation is inspired by Martins et al 2009, and hence uses fewer constraints than Riedel and Clarke (2006). $$$$$ However, global constraints cannot be incorporated into the CLE algorithm (McDonald et al., 2005b).
Our formulation is inspired by Martins et al 2009, and hence uses fewer constraints than Riedel and Clarke (2006). $$$$$ Our approach uses a generic algorithm to solve a complex task.

We suggest scaling techniques that allow to optimally learn such graphs over a large set of typed predicates by first decomposing nodes into components and then applying incremental ILP (Riedel and Clarke, 2006). $$$$$ It has the advantage of being more efficient to learn and parse.
We suggest scaling techniques that allow to optimally learn such graphs over a large set of typed predicates by first decomposing nodes into components and then applying incremental ILP (Riedel and Clarke, 2006). $$$$$ We hope that the incremental approach will allow exact MT decoding for longer sentences.

Another solution for scaling ILP is to employ incremental ILP, which has been used in dependency parsing (Riedel and Clarke, 2006). $$$$$ This is not the case when using ILP.
Another solution for scaling ILP is to employ incremental ILP, which has been used in dependency parsing (Riedel and Clarke, 2006). $$$$$ This could be used to justify using the CLE algorithm to find a initial solution as starting point for the ILP solver (see Section 6).

For instance, to improve the accuracy further, more global constrains capturing the subcategorization correct could be integrated as in Riedel and Clarke (2006). $$$$$ An important question to answer when using global constraints is

Riedel and Clarke (2006) cast dependency parsing as an ILP, but efficient formulations remain an open problem. $$$$$ It has the advantage of being more efficient to learn and parse.
Riedel and Clarke (2006) cast dependency parsing as an ILP, but efficient formulations remain an open problem. $$$$$ There are several explicit formulations of the MST problem as an integer linear program in the literature (Williams, 2002).

If it is extended to labeled parsing (a straightforward extension), our formulation fully subsumes that of Riedel and Clarke (2006), since it allows using the same hard constraints and features while keeping the ILP polynomial in size. $$$$$ This is not the case when using ILP.
If it is extended to labeled parsing (a straightforward extension), our formulation fully subsumes that of Riedel and Clarke (2006), since it allows using the same hard constraints and features while keeping the ILP polynomial in size. $$$$$ We can model higher order features by using an extended set of variables and a modified objective function.

Rather than adding exponentially many constraints, one for each potential cycle (like Riedel and Clarke, 2006), we equivalently replace condition 3 by 3. $$$$$ Instead of adding all the constraints we wish to capture to the formulation, we first solve the program with a fraction of the constraints.
Rather than adding exponentially many constraints, one for each potential cycle (like Riedel and Clarke, 2006), we equivalently replace condition 3 by 3. $$$$$ Instead of adding constraints which forbid all possible cycles in advance (this would result in an exponential number of constraints) we first solve the problem without any cycle constraints.

all of them state-of-the-art parsers based on non-arc-factored models $$$$$ Strong assumptions are also made in the case of McDonald et al.’s (2005b) non-projective dependency parsing model.
all of them state-of-the-art parsers based on non-arc-factored models $$$$$ We apply this dependency parsing approach to Dutch due to the language’s non-projective nature, and take the parser of McDonald et al. (2005b) as a starting point for our model.

The average runtime (across all languages) is 0.632 seconds per sentence, which is in line with existing higher-order parsers and is much faster than the runtimes reported by Riedel and Clarke (2006). $$$$$ However, they use a subset of the CoNLL Alpino treebank with a higher average number of tokens per sentences and also evaluate control relations, thus results are not directly comparable.
The average runtime (across all languages) is 0.632 seconds per sentence, which is in line with existing higher-order parsers and is much faster than the runtimes reported by Riedel and Clarke (2006). $$$$$ We can model higher order features by using an extended set of variables and a modified objective function.

The standard approach to framing dependency parsing as an integer linear program was introduced by (Riedel and Clarke, 2006), who converted the MST parser of (McDonald et al 2005) to use ILP for inference. The key idea is to build a complete graph consisting of tokens of the sentence where each edge is weighted by a learned scoring function. $$$$$ However, in certain applications, such as non-projective dependency parsing and machine translation, the complete formulation of the decoding problem as an integer linear program renders solving intractable.
The standard approach to framing dependency parsing as an integer linear program was introduced by (Riedel and Clarke, 2006), who converted the MST parser of (McDonald et al 2005) to use ILP for inference. The key idea is to build a complete graph consisting of tokens of the sentence where each edge is weighted by a learned scoring function. $$$$$ While previous approaches which use ILP for decoding have solved each integer linear program in one run, we incrementally add constraints and solve the resulting program until no more constraints are violated.
